% options:
% thesis=B bachelor's thesis
% thesis=M master's thesis
% czech thesis in Czech language
% english thesis in English language
% hidelinks remove colour boxes around hyperlinks

\documentclass[thesis=M,english]{FITthesis}[2018/10/20]

% \usepackage[utf8]{inputenc} % LaTeX source encoded as UTF-8
% \usepackage[latin2]{inputenc} % LaTeX source encoded as ISO-8859-2
% \usepackage[cp1250]{inputenc} % LaTeX source encoded as Windows-1250

\usepackage{graphicx} %graphics files inclusion
\usepackage{listings}
\usepackage[utf8]{inputenc}
% \usepackage{subfig} %subfigures
% \usepackage{amsmath} %advanced maths
% \usepackage{amssymb} %additional math symbols

\newcommand{\code}[1]{\texttt{#1}}
\usepackage{float}

\setcounter{tocdepth}{3}% Include \substryAubsection in ToC

\usepackage{svg}

\usepackage{dirtree} %directory tree visualisation

% % list of acronyms
% \usepackage[acronym,nonumberlist,toc,numberedsection=autolabel]{glossaries}
% \iflanguage{czech}{\renewcommand*{\acronymname}{Seznam pou{\v z}it{\' y}ch zkratek}}{}
% \makeglossaries

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% EDIT THIS
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\department{Department of System Programming}
\title{GNU-R Debugger Bytecode Support}
\authorGN{Ale{\v s}} %author's given name/names
\authorFN{Saska} %author's surname
\author{Ale{\v s} Saska} %author's name without academic degrees
\authorWithDegrees{Bc. Ale{\v s} Saska} %author's name with academic degrees
\supervisor{Ing. Petr M{\' a}j}
\acknowledgements{Thanks to my adviser Petr M{\' a}j for help with reviewing thesis, Tom{\' a}{\v s} Kalibera for useful help with the GNU-R code and functionality, my father for assisting with the submission of this work, and big thanks to my girlfriend Leslie Ronish for psychological support and all the tea required to make this work happen.}
\abstractEN{First part of this thesis is about analysis and implementation of the bytecode disassembler tool for GNU-R language. Second part of the work is about debugging of the bytecode subsystem of the GNU-R language which is in current version unsufficient because it is implemented through fallback into the AST subsystem. This absence is fixed in this work with implementation of the native bytecode debugger. In order to implement the debugger there was also designed and implemented the bytecode stack printer. The debugger was designed with focus on not doing any negative evaluation performace slowdown which was proved in the end during testing phase.}

\abstractCS{Úvodní část této práce se zabývá analýzou a implementací disassembleru pro jazyk GNU-R. Druhá část práce se zabývá debugováním bytecode subsystému GNU-R jazyka, která je ve stávající verzi nedostatečná, jelikož je implementovaní pouze přes volání AST interpreteru. Tento nedostatek byl odstraněn v této práci za implementaci nativního bytecode debuggeru. K implementaci debuggeru byl navrhnut a později implementován nástroj pro výpis bytecode stacku. Debugger byl navrhnut s cílem na nezpomalení běhu interpteteru jazyku, což bylo ověřeno na konci práce během testování.}

\placeForDeclarationOfAuthenticity{Prague}
\keywordsCS{programovací jazyk,VM,R,GNU-R,disassembler,debugger}
\keywordsEN{computer language,R,GNU-R,bytecode,disassembler,debugger}
\declarationOfAuthenticityOption{1} %select as appropriate, according to the desired license (integer 1-6)
% \website{http://site.example/thesis} %optional thesis URL



\begin{document}

%\captionsetup{justification=centering}

% \newacronym{CVUT}{{\v C}VUT}{{\v C}esk{\' e} vysok{\' e} u{\v c}en{\' i} technick{\' e} v Praze}
% \newacronym{FIT}{FIT}{Fakulta informa{\v c}n{\' i}ch technologi{\' i}}

\setsecnumdepth{part}
\chapter{Introduction}\label{introduction}

\section{Motivation and objectives}\label{motivation-and-objectives}

Almost everyone who has written computer programs has made some logical mistakes while writing them. To help solve these issues, programmers usually run program \textbf{step-by-step} with debugging tools. The \mbox{GNU-R}, which is one of the most widely used scientific languages across the whole entire world, also has the implementation for debugging code.

GNU-R language is a dynamically typed interpreted language, which usually means that it needs Virtual Machine to interpret. There are more ways to represent and implement its evaluation. The first one Abstract Syntax Tree~(see~\ref{AST}) evaluation is the simplest one. To speed up its internal evaluation, the Bytecode~(see~\ref{BC}) compiler and interpreter has previously been introduced into \mbox{GNU-R} language~\cite{r-compiler-some-first-experiments}.

While the abstract syntax tree evaluator is the slowest of the two GNU-R interpreters, it already contains the debugging features implemented. However, it was previously difficult to analyze and debug the other analyzer, bytecode. The only method provided to analyze the bytecode is a very basic disassembler that shows the data in a jargon heavy view. It also means that there is currently no support for debugging the GNU-R bytecode evaluation. When the user requests the debugging feature, the GNU-R core currently has to switch into the AST interpreter instead of performing debugging the bytecode. The slight differences in representation of code between the bytecode and AST can potentially cause an issue when debugging because the debugged code is always only being performed on the AST regardless of whether the user is aware. Eventually, this can also cause an issue when there is an error inside the AST or the BC interpreter core. This can result in a confusing and tough to solve issue. There is also no way for the user to see the internal variables and state of the BC interpreter.

Therefore, the work done in this thesis aims to solve the insufficient bytecode disassembler by replacing it with a new easy-to-use and human-friendly one. Another implemented feature is the advanced and user-friendly bytecode debugger, which is significantly improving the options for analysis and debugging. On top of this, the \code{breakpoint()} instruction which is used for the simulation of the conditional breakpoints was implemented. 

The focus of the implementation was to maintain the performance of the language~(the bytecode engine). The performance testing at the end of this work confirmed this~(see~\ref{performance-testing}). The disassembler \code{bctools} package has automated tests that improve its maintenance in the future. 

This thesis is organized as follows: Section~\ref{introduction} is the introduction to problems in the current GNU-R debugging features. Section~\ref{analysis-of-disassembler} contains the analysis of possible solutions of how to implement the bytecode disassembler and the debugger. Section~\ref{realization} is describing the design of current implementation. Section~\ref{testing-and-future-work} describes what type of testing has been performed on the work. Section~\ref{testing-and-future-work} proposes the future improvements possible due to this thesis and is followed by thesis summarization in conclusion~\ref{conclusion}.

\setsecnumdepth{all}

\chapter{Analysis and design}

\section{GNU-R from user perspective}\label{R-UI}

\subsection{Basis usage~(main commands and REPL loop)}\label{REPL}

The main GNU-R language is written as the console application evaluating the infinite REPL - Read Eval Print Loop. As the abbreviation says, it is evaluating the expressions right as is entered by the user~(of the \code{R} program) to the program standard input~(\code{stdin}). Alongside of this, there is also the \code{Rscript} command in the package which supports running the program from the input file. However, it is internally implemented just as wrapper piping the file content into the \code{R} command.

\subsection{GNU-R package system}\label{R-Packages}

The bytecode disassembler in this thesis is written as the separate package named \code{bctools}. It allows the disassembly tool to be implemented as a plugin into the language. This design is helping to keep the language core minimal. 

Because of this we need to be able to manipulate the packages and work with them. These are few basic commands used for this purpose:

\begin{itemize}
	\item \code{R CMD INSTALL $<$pkgs$>$ } - install specified packages
	\item \code{R CMD build $<$pkgname$>$} - build the package
	\item \code{R CMD check $<$pkgname$>$} - check package~(check requirements, run tests, etc.)
\end{itemize}



\subsection{GNU-R class system}\label{R-Classes}

According to the Hadley Wickham's article~\cite{R-OO}, the GNU-R has 4 possible class systems - \code{S3}, \code{S4}, Reference classes and Base classes~(internally used). It means that the R class system is not strictly defined as in languages like Java, C++, Python, etc. The whole system provides the end user to more flexibility, but on the other hand, it can be a little bit more confusing for the programmers who are used to conventional programming languages.

\section{GNU-R Virtual Machine internal structure}\label{R-internal-structure}

Static languages compilers usually use directly the computer operating system as the running environment. However, the GNU-R is the dynamically typed computer language with the internal Virtual Machine~(VM) providing the running environment.
It is simulating the environment by executing code, managing memory, and providing communication layer with the underlying computer and its external devices ( accessing the filesystem, network communication, etc. ). The nature of all being simulated usually results in performance slowdown, but on the other hand, there is s significant safety advantage of isolation which results of the code being much safer.

The GNU-R stack-based Virtual Machine. They are the simpler ones because every instruction arguments lie on the top of the stack in the specified order (for example \code{ADD} instruction removes two topmost arguments from the stack, make the addition, and push back the result to the stack). The simplicity of instruction coding implies easier instructions and also easier implementation of both compiler and evaluation code.

\subsection{Source code of the GNU-R}\label{source-code-of-gnu-r}

The core GNU-R VM core is written in C language with the broad number of supported platforms~(Windows/MAC/Linux...) and computer architectures~(ARM/x86/x64...). The multi-compiler support also means that there could be the difference in supported features which would need conditional checks for supporting this feature in the compiler code. One of the examples is support for the Computed GOTO~\ref{Computed-GOTO}.

\subsection{Implementation of the core features of the language in R itself}

The GNU-R has internally written the loading mechanism in the way that the \code{base} package is loaded first and then all of the packages contained in list \code{getOption("defaultPackages")} are loaded into the global environment. This mechanism allows that just the core features and language constructs are written in performance-optimized \code{C}, and the rest can be written inside R language itself. It means that these packages there is substantial amount of functionality for the whole language. The \code{compiler} package is different than the other packages because its code is used inside the language core interpreter. It means that the \code{compiler} package needs to be loaded before any of the other packages. It causes the the loading mechanism to be hardcoded in the language evaluator code~(which makes it different to the other packages). Its loading is inside \code{loadCompilerNamespace} function~(in the \textit{src/main/eval.c} file). The same concept about loading to the language intepreter core has to be used for our bytecode disassembler \code{bctools}~\ref{implementation-of-disassembler} package~(because the disassembler functionality is used inside bytecode evaluator engine).

\subsection{Calling internal C functions from R}

According to the GNU-R documentation~\cite{R_INTERNAL} the C code compiled into R at build time can be called directly in what are termed primitives or via the \code{.Internal} interface. More precisely, R keeps a table of function names and corresponding C functions to call, which by convention all start with \code{do{\_}} and return the result value. This table (\code{R{\_}FunTab} sitting in file \textit{src/main/names.c}) also specifies how many arguments to a function are required or allowed, whether or not the arguments are to be evaluated before calling, and whether the function is internal in the sense that it must be accessed via the \code{.Internal} interface, or directly accessible in which case it is printed in R as \code{.Primitive}. The function table was used in this thesis for defining the native calls for the functions mostly used for manipulating the bytecode~(\ref{setting-and-unsetting-debug-instruction}) and for handling of the status variables for the debugger~(\ref{verbosity-and-formatting}).
\subsection{GNU-R memory types and memory management}\label{memory-management}

Each memory node is represented as \code{SEXP} type. It contains internal representations such as code definition ( \code{LANGSXP}, \code{BCOSESXP}, \code{WEAKREFSXP}, promises, etc. ) and also regular memory types (such as logical vectors, integer vectors, strings vectors, etc.). GNU-R is a vector language, so every value is internally represented as a vector (e.g., integer 3 is represented and boxed as \code{INTSXP} vector of size 1 containing value 3).

Types of memory nodes are

\begin{itemize}
	\item \textbf{NILSXP} nil = NULL
	\item \textbf{SYMSXP}	     symbols
	\item \textbf{LISTSXP}	     lists of dotted pairs
	\item \textbf{CLOSXP}	     closures
	\item \textbf{ENVSXP}	     environments
	\item \textbf{PROMSXP}	     promises: [un]evaluated closure arguments
	\item \textbf{LANGSXP}	     language constructs (special lists)
	\item \textbf{SPECIALSXP}   	special forms
	\item \textbf{BUILTINSXP}   	builtin non-special forms
	\item \textbf{CHARSXP}	     "scalar" string type (internal only)
	\item \textbf{LGLSXP}	    logical vectors
% 11 and 12 were factors and ordered factors in the 1990s
	\item \textbf{INTSXP}	    integer vectors
	\item \textbf{REALSXP}	    real variables
	\item \textbf{CPLXSXP}	    complex variables
	\item \textbf{STRSXP}	    string vectors
	\item \textbf{DOTSXP}	    dot-dot-dot object
	\item \textbf{ANYSXP}	    make "any" args work.
%			     Used in specifying types for symbol
%			     registration to mean anything is okay
	\item \textbf{VECSXP}	    generic vectors
	\item \textbf{EXPRSXP}	    expressions vectors
	\item \textbf{BCODESXP}    byte code
	\item \textbf{EXTPTRSXP}   external pointer
	\item \textbf{WEAKREFSXP}  weak reference
	\item \textbf{RAWSXP}      raw bytes
	\item \textbf{S4SXP}       S4, non-vector
% used for detecting PROTECT issues in memory.c
	\item \textbf{NEWSXP}      fresh node created in new page
	\item \textbf{FREESXP}     node released by GC

	\item \textbf{FUNSXP}      Closure or Builtin or Special
\end{itemize}

These types are holding values which can be printed in the disassembler function~\ref{implementation-of-disassembler} and also inside the stack printer~\ref{printing-stack-values} in this thesis.

\subsection{GNU-R garbage collector}\label{GC}

The memory management in dynamic languages is maintained by  \textbf{Garbage Collector}. It releases allocated memory once it is no longer used by program. GNU-R implementation of memory management lies inside \textit{src/main/memory.c}. It implements a non-moving generational garbage collector with two or three generations. Memory is allocated by \code{R{\_}alloc} and is maintained in a stack. There is also protection stack managed by \code{PROTECT}~(and \code{UNPROTECT}) functions which is used inside C code for internal purposes~(widely used in~\ref{implementation-of-debugger}). It allows to push locally allocated variables into it so they are reachable by the garbage collector and would not get removed during a garbage collection run~(memory cleanup).

\subsection{Computed GOTO}\label{Computed-GOTO}

The Computed GOTO technique is used in the VM for code evaluation speedup. Also, the GNU-R VM has its internal support for this feature~(managed by macro \code{THREADED{\_}CODE}). Because the DEBUG instruction is internally dispatching an old previous instruction after execution of debug features there was a need to understand the whole bytecode instruction jumping. 

GNU-R has the support of threaded code~(implemented by the computed GOTO technique) although there is still support for non-GCC compilers~(and compilers which does not support this feature) - see~\ref{source-code-of-gnu-r}. Enabling or disabling of this feature is managed by (\code{THREADED{\_}CODE} \code{define} preprocessor command. 

The all of the while loop and switch cases are in the GNU-R code defined with macros~(\code{INITIALIZE{\_}MACHINE}, \code{BEGIN{\_}MACHINE}, \code{OP}, \code{NEXT} and \code{LASTOP}). They are conditionally defined to either be compiled for supporting Computed GOTO~\ref{computed-goto-used} or not~\ref{computed-goto-used}~(according to the \code{THREADED{\_}CODE} flag).

This feature has impact on the implementation of the bytecode breakpoint instruction jumping to the specified instruction~(see~\ref{threaded-and-non-threaded-design}). It means that this jumping feature has to be implemented and tested for both dispatch systems~(both \code{THREADED{\_}CODE} enabled and disabled).

\subsubsection{Computed GOTO not used - Switch dispatch}\label{computed-goto-not-used}

The internal representation of the traditional implementation of the BC evaluator acts like big loop going through all function instructions. This design causes that in each loop step there has to be branching of program flow according to instruction~(\code{if} command). In the traditional way, this is done as the switch-case where case values are the instruction codes. Example of this approach:

\begin{figure}[H]
\begin{lstlisting}
while(1){
  switch(*opcode++){
    case POP:	//POP=1
      ... do instruction POP ....
      break;
    case GETVAR:	//GETVAR=2
      ... do instruction GETVAR ....
      break;
    case ADD:	//GETVAR=3
      ... do instruction ADD ....
      break;
  }
}
\end{lstlisting}
\caption{\label{fig:goto-not-used} Example of the VM with switch dispatch architecture.}
\end{figure}

\subsubsection{Computed GOTO used - threaded code}\label{computed-goto-used}

The \code{switch} statement should be implemented very efficiently by C compilers - the condition serves as an offset into a lookup table that says where to jump next which means that it is evaluated for every bytecode instruction. However, it turns out that there's a popular GCC extension that allows the compiler to generate even faster code. The main idea behind this is to store the address of the label into the value of a variable which allows the dynamic lookup of the next value.

\begin{figure}[H]
\begin{lstlisting}
/* The indices of labels in the dispatch_table
 * are the relevant opcodes
 */
static void* dispatch_table[] = {
        &&do_halt, &&do_inc, &&do_dec, &&do_mul2,
        &&do_div2, &&do_add7, &&do_neg};
#define DISPATCH() goto *dispatch_table[code[pc++]]

int pc = 0;
int val = initval;

DISPATCH();
while (1) {
    do_halt:
        return val;
    do_inc:
        val++;
        DISPATCH();
    do_dec:
        val--;
        DISPATCH();
    do_mul2:
        val *= 2;
        DISPATCH();
}
\end{lstlisting}
\caption{\label{fig:goto-used-table} Example of the VM with computed goto architecture through dispatch table.}
\end{figure}

In the GNU-R implementation of bytecode interpreter, there is performance optimization called \textit{direct threaded code} associated with dispatch table and the computed GOTO. In process of loading bytecode into the VM internal structure~(done by \code{R{\_}bcDecode} and \code{R{\_}bcEncode} functions inside \textit{src/main/eval.c}) there is translation between instruction codes~(integer codes) and the current location of jump labels inside \code{bcEval} - see \textit{computed goto}~\ref{AST}(\code{void*} type). The nature of the operating system loader would cause that this position can~(and usually is) changed every time the program is started~(R VM is loaded into memory by a operating system) - so value has to be computed every time again. This allows BC interpreter to jump directly at the position which is stored inside the code array. It would cause saving one array lookup every step of BC interpreter compared to the classic interpreter~(implemented for example inside CPython VM).

\subsection{Abstract Syntax Tree}\label{AST}

To be able to internally interpret the syntax of every language the code is first parsed into abstract syntax tree~(AST, see the example in fig.~\ref{fig:ast-while}). Tree in the GNU-R contains nodes of LANGSXP type with references to the symbol table~(pointers to the function). These references are represented as an pointers to functions which have implemented the evaluation of the code. This tree is then traversed and evaluated inside \code{eval} function~(which lies in file \textit{src/main/eval.c}). The evaluator also has built-in support for debugging which is done internally by the checking of the \code{RDEBUG} flag of the current executed environment. The flag is checked every evaluator step which creates performance overhead even though the debug mode is not active. However this checking overhead is usually minimized by branch prediction feature of current CPUs. 

The current AST evaluator debugging implementation was in this thesis used as an inspiration for the functionality of the newly implemented features~\ref{implementation-of-debugger}. The other thing inspired by the this debugger is the user-output in case the bytecode debugger is in the non-verbose mode. In that case the bytecode debugger is simulating the command-line behavior of the AST - see section~\ref{short-compact-way-of-status-printing}.

%TODO: reference to the branch prediction

\begin{figure}[H]\centering
	\includegraphics{Abstract-syntax-tree-of-the-while-loop}
	\caption{While loop example - taken from~\cite{WHILE_LOOP_EXAMPLE}}\label{fig:ast-while}
\end{figure}

\subsection{Bytecode}\label{BC}

Another option how to represent the source code to evaluate is the bytecode. It has an array of transferable instruction codes and constants designed for easy evaluation. The name bytecode stems from the the instruction set that have one byte operation code. Structure contains the instruction code which follows parameters (depending on how many / if parameter given instruction have ). This thesis content is about an implementation of support for the bytecode evaluator of an GNU-R language.

\subsection{Just in Time compilation}\label{JIT}

In order to speed-up evaluation of inside VM, there have been developed various techniques of the performance optimization. One of them is Just in Time~(JIT) compilation of code~\cite{r-jit-speedup}. The underlying idea is to internally translate code into some more efficient representation (from AST to either Bytecode or to the native machine code). However, this transformation (compilation) is usually pretty expensive so it is called once the execution of a specified piece of code reached some limit.
GNU-R has the basic internal support of JIT. Implementation lies inside \code{src/main/eval.c} mainly in functions \code{R{\_}CheckJIT} and \code{R{\_}cmpfun} ). It is executing the \code{Compiler::tryCmpfun} to compile function AST into bytecode. According to the posts from running code with ByteCode, the JIT enables speedup up to 10 times~(theoretically up to 25 times but these cases are very rare).
This means that the bytecode engine of GNU-R code can be used even without a user knowing it~(explicitly calling compilation) which would make work for the bytecode debugger in our thesis very important. The second important thing is that both interpreters~(AST and BC one) can be run together therefore there has to be a need to clearly decide which is currently in use~(this feature is implemented in chapter~\ref{bytecode-interpreter-internal-status}).

\subsection{Promises}\label{computer-promises}

GNU-R computer language is heavily dependent on the promise pattern which implementation has to be handled in the stack printer tool~\ref{implementation-of-stack-printer}. This promise pattern represents a encapsulation of executable code which can be at some time in the future evaluated~(instead of running it immediately). For example instead direct call (see figure~\ref{fig:reading-csv-without-promise}) you can manually force GNU-R to wrap the function evaluation in the promise via the \code{future} function (see figure~\ref{fig:reading-csv-with-promise}).

\begin{figure}[H]
\begin{lstlisting}
#fires immediatelly the read function
value <- read.csv(... some datafile ...)

#just prints the value
print(value)
\end{lstlisting}
\caption{\label{fig:reading-csv-without-promise} GNU-R - reading an data from csv table}
\end{figure}

\begin{figure}[H]
\begin{lstlisting}
#create just an promise containing the read function call
value <- future(read.csv(... some datafile ...))

#evaluates the promise (do the read.csv function)
#  on the background
#  and finally printing out the result
print(value)
\end{lstlisting}
\caption{\label{fig:reading-csv-with-promise} GNU-R - reading an data from csv table wrapped in promise}
\end{figure}


\begin{figure}[H]
\begin{lstlisting}
getB <- function(){
	print("getB")
	5
}

calc <- function(a,b){
	print("calc enter")
	ret <- a*2
	print("accessB")
	ret <- b*10
	print("calc exit")
}
calc(2,getB())

#will produce output:
# [1] "calc enter"
# [1] "accessB"
# [1] "getB"
# [1] "calc exit"
\end{lstlisting}
\caption{\label{fig:gnu-r-promise-arguments} GNU-R - example of promise based arguments evaluation}
\end{figure}

This shown approach is manual and pretty straightforward for the user to understand. However, the GNU-R has promise based lazy evaluation of arguments~\cite{R_PERFORMANCE}. Every argument in the function is the promise and instead of evaluating it before the function call~(like in other old-fashioned languages like \code{C} or \code{Java}), the argument is evaluated inside the function code once it is accessed~(see the figure~\ref{fig:gnu-r-promise-arguments}). It causes that the GNU-R is internally heavy dependent on the promises even it is not obvious for the normal user at the first sight. The promises and printing of their content was done in this thesis in the stack printer~\ref{implementation-of-stack-printer}.


\section{GNU-R Bytecode}

GNU-R has the internal support of the BC which consists of \code{compiler} package for compiling to the bytecode. The language bytecode is interpreter by function \code{bcEval}~(inside \textit{src/main/eval.c}). The BC compiler can be used explicitly by calling certain functions to carry out compilations or implicitly by enabling compilation to occur automatically at certain points.

\begin{itemize}
  \item \textbf{Explicit compilation} - primary functions are: \code{compile}, \code{cmpfun}, \code{cmpfile}
  \item \textbf{Implicit compilation} - can be used to compile packages as they are installed or for JIT compilation of functions or expressions.

For now, the compilation of packages is enabled by calling \code{compilePKGS} with argument \code{TRUE} or by starting R with the environment variable \code{R{\_}COMPILE{\_}PKGS} set to the positive integer value.
\end{itemize}


\subsection{GNU-R internal representation of bytecode}\label{R-internal-bc-representation}

The internal representation of bytecode is \code{SEXP} node of \code{BCODESXP} type. It is internally represented as a linked list~(CONS of cells) of two variables:
\begin{itemize}
	\item \textbf{Bytecode code}~(body) array which contains set bytecode instructions following its' parameters

		\hspace*{6mm} internally represented as first element~(\textit{CAR}) of the list

		\hspace*{6mm} accessed in the code through the \code{BCODE{\_}CODE} macro

		\hspace*{6mm} The array contains the representation of version number followed by the bytecode instructions

	\item \textbf{Constant pool} array

		\hspace*{6mm} internally represented as second element~(\textit{CDR}) of the linked list

		\hspace*{6mm} accessed in the code through the \code{BCODE{\_}CONSTS} macro

		\hspace*{6mm} contains the of the constant expressions~(which are referenced in the bytecode array)

\end{itemize}

\subsection{Expression and source references}\label{Exprref-and-srcref}

At the end of the constant pool array, there can be~(are optional) some additional information about the bytecode~(citing the Source References article \cite{r-srcrefs}). This information is not used for the evaluation but are provided for specifying the original location of the compiled code. They are used in the disassembler tool~\ref{implementation-of-disassembler} and are used in the implemented feature which is doing jumping granularity restriction~\ref{debugger-jumping-granuality}. They can be of 2 types:

\begin{itemize}
	\item \textbf{Expression reference}

describing the expression representation of bytecode~(for example \textit{b+a+4})

	\item \textbf{Source reference}

describing the location in the source file~(for example \textit{main.R{\#}4})
\end{itemize}

The data structures in the end of the constant array can contain these class types:

\begin{itemize}
	\item \textbf{srcref}

Source reference representing the whole function~(it's beginning)

	\item \textbf{srcrefsIndex}

Array corresponding source references to code for each instruction~(length of the array is length of BC code array - see~\ref{R-internal-bc-representation})

	\item \textbf{expressionsIndex}

Array corresponding expression references~(expressions) to code for each instruction~(length of the array is the length of BC code array - see~\ref{R-internal-bc-representation})

\end{itemize}

\section{Current implementation of AST debugger}\label{AST-debugger}

The current implementation of debugger inside GNU-R language is made on top of the AST interpreter and it uses the \code{RDEBUG} flag of current evaluated to check if enable the debugging features. For user, there are written functions~(user interface) managing this functionality. They are:

\begin{itemize}
	\item \code{debug(fun, text = "", condition = NULL, signature = NULL)}

	\hspace*{6mm} enables debug features on the function~\code{fun}

	\item \code{debugonce(fun, text = "", condition = NULL, signature = NULL)}

	\hspace*{6mm} run debug features on the function~\code{fun} next time it is called

	\item \code{undebug(fun, signature = NULL)}

	\hspace*{6mm} disable debug features on the function~\code{fun}

	\item \code{isdebugged(fun, signature = NULL)}

	\hspace*{6mm} check whether the debugging features on the function~\code{fun} are enabled

	\item \code{debuggingState(on = NULL)}

	\hspace*{6mm} manages the debugging features by turning them off / on by managing R internal state

	\hspace*{6mm} returns boolean representing whether debugging is globally turned on. In the case that the \code{on} parameter is not NULL, the internal state is modified according to that parameter.

\end{itemize}

To keep the same debug functionality for functions running on top of the bytecode there is a fallback for switching back to the AST implementation. It implicates that for users the code behaves in the same way~(both BC and AST representation are producing equivalent output), but can cause issues when there are bugs in the internal engine~(either AST or BC evaluator). In that case, the code while debugging would be using the different code than while not-debugging. This can potentially cause confusing and hard to solve issues. 

There is currently also no way to debug BC internals~(stack content and showing the current evaluating instruction in the code) while running. This would be changed in this work by implementing an stack printer~\ref{implementation-of-stack-printer} and disassembler~\ref{implementation-of-disassembler}.

The GNU-R debugger internal implementation of interacting with the user is made by calling the \code{browse()} function which is running the environment browser. Its purpose is to wait for user input. Once the user types expression, it evaluates the typed expression. Its internal representation is reusing the function shared with main REPL loop~(mainly functions \code{Rf{\_}ReplIteration} and \code{ParseBrowser} inside \textit{src/main/main.c}) for support user input~(parsing and evaluating).

The \code{browse()} function also has support for the commands managing the debug mode. They are:
\begin{itemize}
\item \code{c} - exit the browser and continue execution at the next statement.
\item \code{cont} - a synonym for c.
\item \code{f} - finish execution of the current loop or function
\item \code{help} - print this list of commands
\item \code{n} - evaluate the next statement, stepping over function calls. For byte-compiled functions interrupted by browser calls, n is equivalent to c.
\item \code{s} - evaluate the next statement, stepping into function calls. Again, byte-compiled functions make s equivalent to c.
\item \code{where} - print a stack trace of all active function calls.
\item \code{r} - invoke a "resume" restart if one is available; interpreted as an R expression otherwise. Typically "resume" restarts are established for continuing from user interrupts.
\item \code{Q} - exit the browser and the current evaluation and return to the top-level prompt.

\end{itemize}

\section{Current implementation of Bytecode disassembler}\label{current-bc-disassembler}

There is already implemented the way how to see bytecode representation - the bytecode disassembler function \code{disassemble} in \code{compile} package. Even though its current functionality is very minimal and insufficient. It works the way that it converts the code instructions and constant buffer to array which can be after then printed to the console by user~(by default in the REPL loop or manually with \code{print} function). It means that the user would see~(the function would return) two arrays which is user unfriendly. 

\section{Analysis of disassembler improvements}\label{analysis-of-disassembler}

In the following paragraphs, there is a detailed analysis of other implementations of disassemblers and the possibility of implementation advanced one inside GNU-R. The user-interface and output of the disassembler tool~\ref{implementation-of-disassembler} implemented in this thesis was inspired by these implementations.

\subsection{Java bytecode disassembler}

The nice example of the disassembler is in Java language~(\code{javap} command of Java package). However, it works with the Java bytecode which is very specific because each file contains the one class~(the file is named classfile). Although the GNU-R implementation is different - there can be mixed up the non-compiled~(AST) and compiled~(BC) code. It means that the bytecode printer is showing just the one function at once.

\subsection{Python bytecode disassembler}

Python has inbuilt support of disassembler~\cite{Python-disassembler} for it's internal BC~\ref{fig:python-dis-output-example}. It is provided inside package \code{dis} which is part of the package~(no need to manually installing). Source code location is in the \textit{Lib/dis.py}. As you can see the code is showing just one function at once. It is also showing the combined output of constant array at one line~(not printing separately code and constant array). See the figure~\ref{fig:python-dis-output-example} for example.

\begin{figure}[H]
\begin{lstlisting}
import dis

def myfunc(alist):
    return len(alist)

dis.dis(myfunc)
# Generating output
#  2           0 LOAD_GLOBAL              0 (len)
#              2 LOAD_FAST                0 (alist)
#              4 CALL_FUNCTION            1
#              6 RETURN_VALUE

\end{lstlisting}
	\caption{Example output of the python \code{dis} command}\label{fig:python-dis-output-example}
\end{figure}

\subsection{Summary}

The difference between the Java \code{javap} and the Python \code{dis} command is that \code{javap} works on the whole file instead of the Python \code{dis} which is printing just one function. They both dump the BC in the human-readable form with instructions line-by-line. The Python one is showing the parameters from the constant pool altogether with the instruction. The \code{javap} tool, on the other hand, supports more levels of verbosity.

The R can internally combine AST and BC representation of the code. It means that the architecture of the disassembler output cannot be the same as in the \code{javap} command which shows the whole file. Instead of it we can print out to the user the information provided by the old disassemble function which works over the whole functions~(instead of files as the \code{javap command}). The printed out information also have lot of information which are additional information for the user~(not necessary needed to interpret the code). To show these it would be nice if the GNU-R bytecode would have the ability to show these information conditionally according to the verbosity level. The inline showing values from the constant pool~(inspiration by the Python \code{dis} function) would be also useful because it would enable the result to be printed in compact and shorter way.

\section{Analysis of Bytecode debugger implementation}\label{analysis-of-debugger}

Currently, there is no support for debugging the bytecode evaluation~(just the fallback to the AST evaluator is present) so there is no current implementation of the BC debugger to go through. To improve this it should be done the full native implementation of bytecode debugger. User interface of that native debugger implementation can be inspired with the current AST implementation - which is described part~\ref{inspiration-with-current-implementation}. The following parts~(\ref{bcdebug-implementation-in-python} and \ref{bcdebug-implementation-in-v8}) are analyzing the implementation of the BC debugger in other VMs~(Python VM~\ref{bcdebug-implementation-in-python} and V8 javascript VM~ref{bcdebug-implementation-in-v8}).

\subsection{Inspiration with current AST implementation}\label{inspiration-with-current-implementation}

The general idea how to implement the debugger features is taken from the current implementation of the AST debugger~\ref{fig:ast-implementation-of-debugger}. Its implementation of the debug code check if there is \code{RDEBUG} flag on the current executed function. It yes, then it prints information about the current evaluated code~(source reference if available + evaluated expression). After that the \code{do{\_}browser()} command is called which is internally showing the environment browser. The browser has in-build support for evaluating user-entered expressions altogether with support for handling the debugger commands~(\textit{next step}, \textit{step into}, \textit{continue} etc.). It also has support for showing backtrace~(\code{where} command). The environment browser is internally reusing the REPL~\ref{REPL} functionality of whole language~(implemented by the function \code{Rf{\_}ReplIteration} or \code{ParseBuffer} inside \textit{src/main/main.c}).

\begin{figure}[H]
\begin{lstlisting}
if (RDEBUG(rho) && !R_GlobalContext->browserfinish) {
  SrcrefPrompt("debug", R_Srcref);
    //Print "debug" followed by
    //  source reference of the current evaluated code
  PrintValue(CAR(args));
  	//print current evaluated expression
  do_browser(call, op, R_NilValue, rho);
  	//run the environment browser
}
\end{lstlisting}
	\caption{GNU-R AST implementation of the debugger}\label{fig:ast-implementation-of-debugger}
\end{figure}

\subsection{Implementation inside Python VM}\label{bcdebug-implementation-in-python}

One of the good examples of the similar VM is the CPython one which is the most popular Python VM. It is internally supporting just the BC interpreter~(not even having AST evaluator) with the instruction set similar to the GNU-R.

The BC implementation of the its debugger is straightforward. There is implemented runtime checking of the debug flag in the label \code{fast{\_}next{\_}opcode}. To speed up the language evaluation there is a shortcut for dispatching computed goto~(see~\ref{Computed-GOTO}) through dispatch table inside \code{FAST{\_}DISPATCH} macro. Inside this macro is check for the \code{{\!}{\_}Py{\_}TracingPossible} \code{{\&\&}} \code{{\!}PyDTrace{\_}LINE{\_}ENABLED()}~(eventually also combined with the \code{!lltrace} flag). This design of the implementation implicates that debugger implementation is causing performance overhead even while function not being debugged~(for every evaluated BC instruction there is at least one value comparison and conditional jump needed for a processor to compute). However, this implementation is easy to implement, does not require any specific debug instruction and does not cause any changes to the memory subsystem~(potential GC issues). Also, the overhead would in the real-world usage not be huge due to branch prediction feature in the modern CPUs.

%todo add citation for the branch prediction

\subsection{Implementation inside V8 VM}\label{bcdebug-implementation-in-v8}

V8 is Javascript VM developed by the Google. It was initially used by the Chrome browser. By the time it has been also used for desktop~(for example Electron framework) / server applications using the Node.js which is the V8 engine with written filesystem access, networking etc.

The V8 internal implementation is consisting of the BC interpreter~(\textit{Ignition}) and JIT x86 compiler~(\textit{TurboFan})~-see the figure~\ref{fig:ast-v8-architecture}.

The bytecode interpreter is single stack registed based VM~(similarly to the GNU-R and \textit{CPython} VM). Its core functionality of the debugger works on the BC instruction level. The VM defines separate Debug instruction for every number of the arguments~(e.g. \code{DebugBreak0}, \code{DebugBreak1}, \code{DebugBreak2} etc.)~\ref{fig:v8-bc-breakpoint-definitions}.

If the breakpoint is set on some specific instruction~(for example \textit{ShiftRight} instruction with the 2 parameters) it causes its the replacement of the original instruction by the corresponding breakpoint one according to the number of the parameters of original one~(\textit{DebugBreak2} for \textit{ShiftRight} because it has 2 parameters). These BC instructions work like special instructions~\ref{fig:v8-breakpoint-instruction-implementation} which internally calls the handler for the debugger and also dispatch the original instruction to maintain the same behavior~(consistency) of the original code.

\begin{figure}[H]
\begin{lstlisting}
  /* Debug Breakpoints - one for each possible
  		size of unscaled bytecodes */
  /* and one for each operand widening prefix
  		bytecode                    */
  V(DebugBreak0, AccumulatorUse::kReadWrite)
  V(DebugBreak1, AccumulatorUse::kReadWrite,
  		OperandType::kReg)
  V(DebugBreak2, AccumulatorUse::kReadWrite,
  		OperandType::kReg,
    OperandType::kReg)
  V(DebugBreak3, AccumulatorUse::kReadWrite,
  		OperandType::kReg,
    OperandType::kReg, OperandType::kReg)
  V(DebugBreak4, AccumulatorUse::kReadWrite,
  		OperandType::kReg, OperandType::kReg,
  		OperandType::kReg, OperandType::kReg)
  V(DebugBreak5, AccumulatorUse::kReadWrite,
  		OperandType::kRuntimeId, OperandType::kReg,
  		OperandType::kReg)
  V(DebugBreak6, AccumulatorUse::kReadWrite,
  		OperandType::kRuntimeId, OperandType::kReg,
  		OperandType::kReg, OperandType::kReg)
  V(DebugBreakWide, AccumulatorUse::kReadWrite)
  V(DebugBreakExtraWide, AccumulatorUse::kReadWrite)
\end{lstlisting}
	\caption{V8 BC definition for the breakpoint instructions}\label{fig:v8-bc-breakpoint-definitions}
\end{figure}

\begin{figure}[H]
\begin{lstlisting}
// DebugBreak
//
// Call runtime to handle a debug break.
#define DEBUG_BREAK(Name, ...)
  IGNITION_HANDLER(Name, InterpreterAssembler) {
    Node* context = GetContext();
    Node* accumulator = GetAccumulator();
    Node* result_pair =
        CallRuntime(Runtime::kDebugBreakOnBytecode,
        	 context, accumulator);
    Node* return_value = Projection(0, result_pair);
    Node* original_bytecode =
    	SmiUntag(Projection(1, result_pair));
    MaybeDropFrames(context);
    SetAccumulator(return_value);
    DispatchToBytecode(original_bytecode, BytecodeOffset());
  }
DEBUG_BREAK_BYTECODE_LIST(DEBUG_BREAK);
#undef DEBUG_BREAK
\end{lstlisting}
	\caption{V8 current source code implementation of the breakpoint instruction}\label{fig:v8-breakpoint-instruction-implementation}
\end{figure}

\begin{figure}[!h]\centering
	\includegraphics[width=\textwidth]{v8-architecture}
	\caption{V8 internal architecture}\label{fig:ast-v8-architecture}
\end{figure}

%TODO: add citation for the v8 internal representation

\subsection{User interface and state of the BC evaluator}\label{user-interface-and-state-of-the-bc-eval}

To keep the implementation consistent from the user perspective BC debugger should use the same user-interface as the AST. There can also be visible distinguishing between the internal state of the language~(if the language is currently inside the AST or BC evaluation mode). In the current AST implementation, there is used
\code{"debug"} as prefix printed while showing the environment browser in the debugger. This could be modified to the \code{"debugBC"} to signalize the user that the BC debugger is active.

The internal state of the GNU-R BC stack machine should be printed out to the output while the debugging. This state consists of:

\begin{itemize}
	\item Current position inside the code
	\item Stack content
\end{itemize}

Alongside the showing the current position, there would also be need to show the function bytecode. For this feature we can use the disassembler feature~\ref{implementation-of-disassembler} proposed in the first part of the analysis~\ref{analysis-of-disassembler}. Showing current position inside code can be implemented as a feature inside the disassembler but for the stack content, there has to be implemented a separate tool.

\section{Summary}

In order to improve bytecode debugging, there is a need for improving~(implementing the human-readable) disassembler. There was decided that the disassembler would be implemented as the separate \code{print.disassembly} function inside the new \code{bctools} package.

Another part of the thesis is about implementing the native bytecode debugger support into the GNU-R. The solution proposed in this thesis was inspired by the JS~V8~VM~\ref{bcdebug-implementation-in-v8} and Python~VM~\ref{bcdebug-implementation-in-python}. It consists of the implementing set of bytecode instructions~(\code{BREAKPOINT0} through \code{BREAKPOINT4}) alongside with storing of the original instructions in the separate array. This proposed solution is performance oriented because the bytecode debugger architecture should not have any negative effect on overall language performance.

Finally in the debugger, there has to be done some showing of the evaluator internal status to the user. The status consists of the bytecode of the function, current evaluated instruction, and the stack content. For showing the function bytecode and printing the current evaluator position in the code there can be reused the disassembler tool~(see~\ref{analysis-of-disassembler}) but for the dumping of the stack content, there has to be implemented completely new and separate tool.

\chapter{Realization}\label{realization}

There are three different things which have to be implemented - disassembler, stack printer and finally the BC debugger itself.

\section{Implementation of the disassembler}\label{implementation-of-disassembler}

The whole project was structured the way that disassembler can be easily released to the CRAN repository without the debugger. As much as possible code is written in the R language~(most of it in separate package \code{bctools}, but some also to the \code{compiler} one~\label{internal-parts-of-vm}) and just necessary minimum in C for keeping the changes into the GNU-R core code simple.

In the GNU-R language, there is the \code{compiler} package written in R. Inside it there is lying the current BC compiler and BC disassembler~(very minimal - see~\ref{current-bc-disassembler}). The changes made in order to realize the implementation of the advanced disassembler involved also modifying the \code{compiler} package. This package lies inside the GNU-R core code so the general idea about implementation was to put the just the bare minimum inside it~(the annotation of instructions~\ref{annotation-of-instructions} and putting a class into the disassembly code \ref{user-interface}). The most of the functionality was implemented then in the \code{bctools} package.

\subsection{User interface}\label{user-interface}

For better user-friendliness of the BC disassembler there has been made a decision to use the advantage of the S3 class system~(see~\ref{R-Classes}). The old \code{disassemble} function inside the \code{compiler} package was kept intact except the putting class into the disassembly code. The name of the class has been decided to be the \code{"disassembly"}. Having this class then allows us to have \textit{print.disassembly} function~(\textit{print} method of \textit{disassembly} class) inside our \code{bctools} package. That function would be then automatically dispatched once the user calls the \code{print} function on the object~(if the \code{bctools} package would be loaded inside user library).

The usage then changed from simple list (see figure~\ref{fig:old-disassembly-ui}) to the user-friendly disassembly code~(see figure~\ref{fig:new-disassembly-ui}).

\begin{figure}[H]
\begin{lstlisting}
#initialization
library(compiler)
f<-function(x) {
    y <- x*2
    while(x < y)
	x <- x+1

    if(x %% 2 == 0)
	x
    else
	-x
}
compiled <- cmpfun(f)

#disassembly
#  same output due internal to behavior of REPL as the
#    print(disassemble(compiled))
disassemble(compiled)

#generated output:
# list(.Code, list(8L, GETVAR.OP, 1L, LDCONST.OP,
#	2L, MUL.OP, 3L, SETVAR.OP, 4L, POP.OP, GETVAR.OP,
#	1L, GETVAR.OP, 4L, LT.OP, 5L, BRIFNOT.OP, 6L, 30L,
#	GETVAR.OP, 1L, LDCONST.OP, 7L, ADD.OP, 8L,
#	SETVAR.OP, 1L, POP.OP, GOTO.OP, 10L, LDNULL.OP,
#	POP.OP, GETBUILTIN.OP, 9L, GETVAR.OP, 1L, PUSHARG.OP,
#	PUSHCONSTARG.OP, 2L, CALLBUILTIN.OP, 10L, LDCONST.OP,
#	11L, EQ.OP, 12L, BRIFNOT.OP, 13L, 51L, GETVAR.OP,
#	1L, RETURN.OP, GETVAR.OP, 1L, UMINUS.OP, 14L,
#	RETURN.OP), list({
#   y <- x * 2
#   while (x < y) x <- x + 1
#   if (x%%2 == 0)
#       x
#   else -x
#}, x, 2, x * 2, y, x < y, while (x < y) x <- x + 1, 1, x + 1,
#   `%%`, x%%2, 0, x%%2 == 0, if (x%%2 == 0) x else -x, -x))
\end{lstlisting}
	\caption{Old disassembly user interface}\label{fig:old-disassembly-ui}
\end{figure}

\begin{figure}[H]
\begin{lstlisting}
#initialization
library(compiler)
library(bctools) #new package
f<-function(x) {
    while(x < y) x <- x+1

	x
}
compiled <- cmpfun(f)

#disassembly
#  same output due internal to behavior of REPL as the
#    print(disassemble(compiled))
disassemble(compiled)

#generated output:
#
1:
  @ x
  GETVAR              x
  @ 10
  LDCONST             10
  @ x < 10
  LT
  @ while (x < 10) x <- x + 2
  BRIFNOT             while (x < 10) x <- x + 2	 | $2
  @ x
  GETVAR              x
  @ 2
  LDCONST             2
  @ x + 2
  ADD
  @ x <- x + 2
  SETVAR              x
  @ while (x < 10) x <- x + 2
  POP
  GOTO                $1
2:
  LDNULL
  POP
  @ x%%2
  GETBUILTIN          `%%`
  GETVAR              x
  PUSHARG
  PUSHCONSTARG        2
  CALLBUILTIN         x%%2
  @ 0
  LDCONST             0
  @ x%%2 == 0
  EQ
  @ if (x%%2 == 0) x else -x
  BRIFNOT             if (x%%2 == 0) x else -x	 | $3
  @ x
  GETVAR              x
  RETURN
3:
  GETVAR              x
  @ -x
  UMINUS
  RETURN
#
\end{lstlisting}
	\caption{Old disassembly user interface}\label{fig:new-disassembly-ui}
\end{figure}

%TODO: REDO THIS EXAMPLE

\subsection{Instruction arguments}\label{instruction-arguments}
The BC instruction contains an integer code identifying it followed by a variable number of arguments. These arguments can be of different 5 basic types~-~see\ref{fig:bytecode-argument-types}~(\code{BOOL}, \code{INT}, \code{LABEL}, \code{CONSTANT{\_}LABEL} and \code{CONSTANT}).

The \code{CONSTANT} parameter can have two different meanings in the code. Some of the arguments could be a whole expression~(e.g. a+b+c) kept due to usage in some corner cases during evaluation~( e.g., \code{ADD} instruction is in the most cases taking the two topmost variables from the stack. Just in some corner cases, it is calling the internal functions which were initially designed to work on the AST evaluator, so they expect the expression as an input). These additional arguments are then stored only because the internal implementation of the bytecode evaluator and they contain the duplicate information. The optional parameter kept due to internal purposes of evaluator was named a \code{CONSTANT{\_}DBG}.

These arguments are printed by the different functions in the disassembler~(see~\ref{printing-of-different-types}).

\begin{figure}[H]
\begin{itemize}
	\item \code{BOOL} boolean value

	\item \code{INT} integer value

	\item \code{LABEL} - jump target / reference~(integer index) to the code array itself

	\item \code{CONSTANT{\_}LABEL} variation~(extension) of the \textit{LABEL} which allow more than one referenced index

	represented as reference~(integer index) to the constant pool where is located an array containing the references~(integer indexes) to the code array itself

	\item \code{CONSTANT} representing reference~(integer index) to the constant pool where is located constant expression~(can be either number or function)

	used for most of common cases

	\item \code{CONSTANT{\_}DBG} - constant expression inside the argument used internally just for the corner cases~(technically containing duplicitous information)
\end{itemize}
	\caption{Bytecode instruction argument types}\label{fig:bytecode-argument-types}
\end{figure}


\subsection{Annotation of instructions}\label{annotation-of-instructions}
These 6 types~(see figure~\ref{fig:bytecode-argument-types}) should be printed in different way according to the annotation. There has been created a definition for each instruction argument~(annotation of the instructions - see figure~\ref{fig:instruction-annotation-example}). The pretty printing disassembly function~(\code{print.disassembly} method in the \code{bctools} package) can then take instruction definition and print out the arguments accordingly.

In the compiler package, there is already basic annotation specifying the number of arguments for each instruction~(\code{Opcodes.argc} list). This list was replaced by the \code{Opcodes.descr} list containing the fully annotated instruction~(see the figure~\ref{fig:computation-of-argdescr}). To keep the old behavior the old \code{Opcodes.argc} list was computed from \code{Opcodes.argdescr} by applying the \code{length} function to each element~(see figure~\ref{fig:computation-of-argc}). This solution was chosen due to the fact that the definition is made just at one place and there is no need to maintain the two lists.

The \code{compiler} package is made with the \code{noweb} tool which is the tool used for writing documentation alongside with the code. Its source is written in the \textit{src/library/compiler/noweb/compiler.nw} file. Because the build command~(\code{make}) is not written to re-generate the source code from \code{noweb} each time the compiling is provided, we have to rerun the \code{make from-noweb} command inside the \code{compiler} to regenerate the R sources for the \code{compiler} package.

\begin{figure}[H]
\begin{lstlisting}
<<opcode argument description>>=

SKIP.ARGTYPE<--1L
LABEL.ARGTYPE<-0L
CONSTANTS.ARGTYPE<-3L
CONSTANTS_DBG.ARGTYPE<-4L
CONSTANTS_LABEL.ARGTYPE<-5L
BOOL.ARGTYPE<-6L
INT.ARGTYPE<-7L

Opcodes.argdescr <- list(

BCMISMATCH.OP = c(),
RETURN.OP = c(),
GOTO.OP = c(LABEL.ARGTYPE),
BRIFNOT.OP = c(CONSTANTS.ARGTYPE,LABEL.ARGTYPE),
POP.OP = c(),
DUP.OP = c(),
PRINTVALUE.OP = c(),
STARTLOOPCNTXT.OP = c(BOOL.ARGTYPE, LABEL.ARGTYPE),
    #  bool is_for_loop, pc for break
.... all remaining instructions ....
)
\end{lstlisting}
	\caption{Example of instruction annotation}\label{fig:instruction-annotation-example}
\end{figure}

\begin{figure}[H]
\begin{lstlisting}
Opcodes.argc <- lapply(Opcodes.argdescr, length)
\end{lstlisting}
	\caption{Computation of argument count in the compiler package}\label{fig:computation-of-argc}
\end{figure}

\subsection{Instruction arguments and labels}\label{instruction-arguments-labels}

A label is a form of representation of the reference to the code which is used in the jumps through the code.

\subsection{Computing of labels}

Labels are shown in the code in specific styling~(usually incrementally numbered from the 1, e.g., \code{2:}). Arguments are then referencing to these locations~(e.g., \code{{\$}2}).

There is no direct list containing locations of the labels, but this list can be computed from the code. Its generating was done in the two-pass linear lookup through code~(see figure \ref{fig:code-generating-labels}). The result is an auxiliary array containing the number of the label.

Steps to generate labels are then:
\begin{enumerate}
	\item \textbf{Initialize the auxiliary array} with the size of code buffer. Each element has the default value representing the fact, that there is no instruction which argument is pointing to that position.
	\item \textbf{Go through all instruction} in a forward direction. For each argument, if it contains any label~(see labels inside arguments~\ref{instruction-arguments-labels}) mark the position~(which it is pointing to) with information that there is label pointing to that position.
	\item \textbf{Go through the auxiliary array}. If the instruction is marked then replace the mark with the unique number of the label. This number is calculated incrementally~(at the beginning set a counter to 1, and on each marked position set the value of the counter to the array and increment the counter).
\end{enumerate}

The result of this algorithm is an array containing the information whether there is no label at the instruction~(\code{-2}) or the label~(number \code{>=0}).

\begin{figure}[H]
\begin{lstlisting}
#first pass to mark instruction with labels
#labels is array that describes if each	Aq
#    instruction has label
n <- length(code)
#labels now contains -2=not used, -1=used
labels <- rep(-2, n)
i <- 2
instrCnt<-0 # count number of instructions
while( i <= n ) {
    v <- code[[i]]
    argdescr <- Opcodes.argdescr[[paste0(v)]]
    j <- 1
    while(j <= length(argdescr)){
        i<-i+1
        if(argdescr[[j]] == argtypes$LABEL){
            labels[[ code[[i]] + 1 ]] <- -1
        }else if(argdescr[[j]] == argtypes$CONSTANT_LABEL){
            v <- constants[[ code[[i]] + 1 ]]
            if(!is.null(v)){
                for(k in 1:length(v)){
                    labels[[v[[k]] + 1]] <- -1
                }
            }
        }
        j<-j+1
    }
    instrCnt<-instrCnt+1
    i<-i+1
}

#second pass to count labels
#loop through labels array and if
#   that instruction has label marked on it
#labels array now contains values:
#   -2=not used, -1=used, >0=index of label
i <- 2
lastlabelno <- 0;
while( i <= n ) {
    if(labels[[i]] == -1){
        lastlabelno <- lastlabelno+1
        labels[[i]] <- lastlabelno
    }
    i<-i+1
}
\end{lstlisting}
	\caption{Code for generating labels}\label{fig:code-generating-labels}
\end{figure}

\subsection{Verbosity and formatting}\label{verbosity-and-formatting}

Bytecode compiled function can contain the information about a location of the source code~(they are optional).  These data are not necessary for the evaluation of the code but are good for human-readability~(see~\ref{Exprref-and-srcref}). Alongside with this, there are also some of the instruction arguments which are used just for the reason of the internal implementation and have duplicate value~(see the previous~chapter~\ref{instruction-arguments}). All of this information is not necessary to be displayed to the user by default, but it would be nice for them to provide an ability to display even these information. To provide this optional ability to show more basic or more advanced information there has been put a decision to implement more levels of the verbosity in the disassembly tool.

The levels are:

\begin{itemize}
	\item \code{0} - display only source references~(In case they are available. When not they aren't print expression references instead)

	see figure~\ref{fig:disassembly-verbose-0}

	\item \code{1} - the same as 0 + display bytecode version and display expression references ( if they are available )

	see figure~\ref{fig:disassembly-verbose-1}

	\item \code{2} - the same as 1 + display every operand's argument~(including ones used only for internal uses - see~\ref{})

	see figure~\ref{fig:disassembly-verbose-2}

\end{itemize}

The default value can be pre-set by \code{bcverbose} function~(provided in the \code{bctools} package).

\begin{figure}[H]
\begin{lstlisting}
1:
 - #1: function(a) while(a) a <- a-1
  GETVAR              a
  BRIFNOT             while (a) a <- a - 1	 | $2
  GETVAR              a
  LDCONST             1
  SUB
  SETVAR              a
  POP
  GOTO                $1
2:
  LDNULL
  INVISIBLE
  RETURN
\end{lstlisting}
	\caption{Disassembly output with verbose lvl 0}\label{fig:disassembly-verbose-0}
\end{figure}

\begin{figure}[H]
\begin{lstlisting}
Bytecode ver. 10

1:
 - simple_bc_verbosity1.R#4: function(a) while(a) a <- a-1
  @ a
   1: GETVAR              a
  @ while (a) a <- a - 1
   3: BRIFNOT             while (a) a <- a - 1	 | $2
  @ a
   6: GETVAR              a
  @ 1
   8: LDCONST             1
  @ a - 1
  10: SUB
  @ a <- a - 1
  12: SETVAR              a
  @ while (a) a <- a - 1
  14: POP
  15: GOTO                $1
2:
  17: LDNULL
  18: INVISIBLE
  19: RETURN
\end{lstlisting}
	\caption{Disassembly output with verbose lvl 1}\label{fig:disassembly-verbose-1}
\end{figure}

\begin{figure}[H]
\begin{lstlisting}
Bytecode ver. 10

1:
 - simple_bc_verbosity2.R#3: function(a) while(a) a<-a+1
  @ a
   1: GETVAR              a
  @ while (a) a <- a + 1
   3: BRIFNOT             while (a) a <- a + 1	 | $2
  @ a
   6: GETVAR              a
  @ 1
   8: LDCONST             1
  @ a + 1
  10: ADD                 a + 1
  @ a <- a + 1
  12: SETVAR              a
  @ while (a) a <- a + 1
  14: POP
  15: GOTO                $1
2:
  17: LDNULL
  18: INVISIBLE
  19: RETURN
\end{lstlisting}
	\caption{Disassembly output with verbose lvl 2}\label{fig:disassembly-verbose-2}
\end{figure}

%TODO: redo these examples

\subsection{Function types in the constant pool}

The constant expressions in the constant pool can be of more 3 types:

\begin{itemize}
	\item regular~(ordinary) constant expressions~(e.g. numbers, an array of numbers etc.)
	\item native functions~(calls to the inside of the GNU-R C implementation)
	\item BC compiler function code
\end{itemize}

There is no way how to print out the native functions because its structure is written inside the GNU-R runtime core in C language~(the R interpreter knows just the location/function pointer/ to call). These native functions are printed in the bytecode disassembly as an \code{$<$INTERNAL{\_}FUNCTION$>$}.

There are also stored the BC compiled functions in the constant bool. This means that there is recursion of the bytecode functions which we need to solve in the disassembler. The first approach is to print out flag like \code{$<$BYTECODE{\_}FUNCTION$>$}. The second approach is to be able to print it out nested with some indentation. The second one was chosen due to the ability to print out more information. In order to implement this feature there were introduced these 3 parameters in the disassembly tool:

\begin{itemize}
	\item \code{prefix} - the string prefix which is put before each line printed in the whole function

	\item \code{depth} - current depth of the recursion.

	\item \code{maxdepth} - maximal depth for the recursion~(once the \code{depth} reaches this level, the \code{$<$FUNCTION$>$} instead of calling the disassembly print would be shown in the output)
\end{itemize}

This condiguration allows us to have one feature. If the \code{maxdepth} would be set to the 0, the disassembly tool would print out just the \code{$<$BYTECODE{\_}FUNCTION$>$} for every nested bytecode~(the nested BC printing would be disabled).

%TODO: add examples

\subsection{Printing functions}

%The printing of the functions were done by calling an

One type of the constant expressions in the constant array are the functions written as an expression references~(non-byte-compiled and being able to evaluate with \code{eval} function). They have to be printed in a user-friendly way which however would not break the consistency of disassembly output. One way how to achieves that behavior is to call the \code{dput} function. However, it would format the functions line by line which is not the desired output. For making the arguments look as dense as possible~(and not break consistency and compactness of the disassemble function), there has been put decision to write the function in a single line. There are 2 ways how to solve this:

\begin{itemize}
	\item Write a specific call into the \textit{print.c}~(\textit{src/main/print.c}) - \textit{deparse1} function
	\item Call a \code{dput} to print out line-by-line into the buffer by \code{capture.output} and after that make string modifications over this output.
\end{itemize}

The first approach is cleaner that the other in sense of the code. However, it was previously decided to make only a minimal amount of the changes into the C core of the language~(for being able to release the disassembler in the separate package \code{bctools}) so the second way was chosen.

%TODO: maybe add code example

\subsection{Printing of different types}\label{printing-of-different-types}

In the application, there are different types of the actions to print~(e.g. Constants, Operators etc.). The corresponding implementation of printing functions in the disassembler is named by the \code{dumpNAME} convention~(e.g. \code{dumpConstant} ). The complete list of types to print is:

\begin{itemize}
	\item \textbf{Constant}

		used for printing any constant value

		description of the functionality of the whole operator is described in the following chapter subsection~(see~\ref{printing-constant-expressions})

	\item \textbf{Operator}

		used for printing the operator name

		The operator names are received by the \code{bcinfo} function from the \textit{compiler} package with the \code{.OP} suffix~(e.g.,~\code{ADD.OP}). It means that after extracting the suffix these names can be printed.

	\item \textbf{Value}

		used for printing the \code{INT} and the \code{BOOL} argument types

		printing the expression by calling the \textit{cat} function directly

		formatting notation - directly the \code{NUMBER}~(e.g.,~1)

	\item \textbf{Label}

		formatting notation - \$\code{LABEL{\_}NO}~(e.g.,~\$1)

	\item \textbf{\code{SrcRef}} a.k.a. source reference

		formatting notation - \code{SRCREF}~(e.g.,~simple{\_}bc{\_}verbosity1.R{\#}4)

	\item \code{ExprRef} a.k.a. expression reference

		formatting notation - $@$\code{EXPRESSION}~(e.g.,~$@a+1$)

		The expressions are stored in the constant pool, so technically they are a special type of the constant expressions. For printing them, we can reuse the print function for the constant expressions-\code{dumpConstants}. The only difference we need to print the \code{$@$} as prefix. So final implementation of the dump function is printing the $@$ to the output and after that calling the \code{dumpConstants}.

\end{itemize}

%TODO: maybe add code example

\subsection{Documenting of code}

The \code{compiler} package has documentation written altogether with the code. It is managed through \code{noweb} tool~(see~\ref{annotation-of-instructions}).

The \code{bctools} package user-documentation was created with the \code{roxygen} tool~(the GNU-R inbuilt documenting system). There are several ways for a developer to rebuild the documentation~(run the \code{roxygen}):
\begin{itemize}
 \item \code{roxygen2::roxygenise()}, or
 \item \code{devtools::document()}, if the \code{devtools} are used, or
 \item \code{rCtrl + Shift + D}, if the \code{RStudio} is used
\end{itemize}

The second listed~(calling \code{devtools::document()}) was used during an development of this package.

\section{Implementation of the bytecode stack printer}\label{implementation-of-stack-printer}

To implement the BC debugger we need to be able to print the \code{BC} stack content~(see~\ref{user-interface-and-state-of-the-bc-eval}). The way how the implementation was designed is that it was written in the C language~(GNU-R language core). This tool was designed to be called with two parameters:
\begin{itemize}
	\item pointer to the beginning of the stack frame
	\item pointer to the end of the stack frame
\end{itemize}

This design allows to print out any of the stack frame~(or eventually stack frame chunk).

\subsection{Stack definition}\label{stack-definition}

Stack definition depends on the \code{TYPED{\_}STACK} typedef conditional~(see figure~\ref{fig:stack-elements-definition}). Once it is defined, the ability to save the unboxed values on the stack is enabled. It causes that instead of the \code{SEXP} stored in the stack every time~(which is more expensive to handle), there could also be stored raw values~(\code{int} or \code{double}). There is also \code{RAWMEM} memory which is used in the BC evaluator to store any data chunk - for example evaluation context frame. Once the stack is enabled, the stack values could be then out of these types:

\begin{itemize}
	\item \textbf{\code{int}}
	\item \textbf{\code{double}}
	\item \textbf{\code{RAWMEM}} - a piece of raw memory

		its size is defined in a number of \code{sizeof(SEXP)} sized chunks
	\item \textbf{\code{SEXP}} - internal representation of the boxed object storing any value
\end{itemize}

To be able not to have to write a specific code for each stack type there is used a macro \code{GETSTACK{\_}PTR} returning a boxed \code{SEXP} type equivalent of stack position~(no matter if the value in stack is boxed or not). Ability to get the boxed value of the stack means that we can handle every place on the stack the same (except the \code{RAWMEM}).

\subsection{Printing of the stack values}\label{printing-stack-values}

The printing of stack values is done through a direct call of \code{deparse1} function in the C core. It is inspired by the \code{dput} function which is used for writing an \code{ASCII} representation of the R object to the text output or file. The \code{dput} function cannot be reused without any changes because it is internally evaluating the promises while dumping the output~(see~\ref{computer-promises}). However the evaluating of the promises can potentially introduce some unwanted side-effects. To disable the evaluating the promises, the \code{deparse1} function was then called with the \code{DELAYPROMISES} argument~(instead of evaluating the promises it is showing \code{$<$promise$>$} text).

\subsection{RAWMEM stack type tag}\label{rawmem-stack-tag}

In case the \code{TYPED{\_}STACK} is defined~(see~\ref{stack-definition}) then the stack values can contain raw memory chunks which cannot be printed~(see figure~\ref{fig:stack-elements-definition}). Information about the size of these chunks is directed to the top of the stack~(from bottom to the top). However we want to print the values in the direction from the top to the down. It results in the question whether the cell is printable or not. To be able to answer this question there has been created an auxiliary array containing the values if the cell is printable~(see figure~\ref{fig:stack-elements-definition}). It is causing some additional complexity by running one more linear pass through the stack~(to fill out this array). This pass is in the forward order~(from bottom to top of the stack), so we can tell whether the memory is the raw or not. The added additional complexity is not our biggest concern because this feature would be used just in case the debugger is turned on and in this case we are strict about the performance, because the program would be waiting for the user input anyways.

\begin{figure}[H]
	\includegraphics[width=90mm]{stack-rawmem.png}
	\caption{Definition of stack elements and generated auxiliary array showing the pritable elements}\label{fig:stack-elements-definition}
\end{figure}

The whole algorithm to dump the stack then has two passes:

\begin{itemize}
	\item The \textbf{first pass} from bottom to top to fill out the auxiliary array.

			Sets the \code{TRUE} value on the visited value. If the visited value is the \code{RAWMEM} type, then mark the n following~(size parameter of the \code{RAWMEM} cell) cells \code{FALSE}.

	\item The \textbf{second pass} from top to bottom to print out the values on the stack.

			Works in the way that skip values for every place where there are set auxiliary value to FALSE. If it is set to TRUE then look at the tag~(if \code{TYPED{\_}STACK} available) whether is \code{RAWMEM}. In case it is \code{RAWMEM} then print the \code{$<$rawmem of size \%d$>$}, otherwise call the \code{print} function for the \code{SEXP} value~(see~\ref{printing-stack-values}) to print out the value laying on the position.
\end{itemize}

The \code{TYPED{\_}STACK}, however, could also be disabled. It means that there cannot be \code{RAWMEM} stored on the stack. Even though we decided to keep the whole algorithm intact which would result in the auxiliary array having just the \code{TRUE} values~(every item is printable). This decision would cause better maintainability of the code because there are less \code{IFDEF} preprocessor conditions.

\subsection{Persisting stack pointers}\label{persisting-stack-pointers}

In regards to the BC stack information, there are currently these~(global) variables representing the current state.

\begin{itemize}
	\item \textbf{R{\_}BCNodeStackBase} - the bottom of the stack
	\item \textbf{R{\_}BCNodeStackTop} - current top of the stack
	\item \textbf{R{\_}BCNodeStackEnd} - the end of allocated space for the stack~(stack is represented internally as an array)
\end{itemize}

all of these satisfying an equation:

$R{\_}BCNodeStackBase <= R{\_}BCNodeStackTop <= R{\_}BCNodeStackEnd$


To be able to print values on the bytecode frame stack we need to know when function stack frame starts and ends~(\textit{R{\_}BCNodeStackBase} points to the bottom of the whole stack and not function). There is currently not any enough information from which easily we can get a start of the function stack frame. To achieve this, there has been added the \code{R{\_}BCNodeStackFnBase} variable representing a begin of function stack frame. It is global variable but kept and managed through context handling~(in the \textit{src/main/context.c}) to simulate the CPU function register stack frame.

\section{Implementation of the debugger}\label{implementation-of-debugger}

The primary purpose of this work is to enable the bytecode debugging in a user-friendly way. To do debugging we need to visualize the current bytecode internal state of the evaluating function~(debugger work in each function separately) which consists of:

\begin{itemize}
	\item Bytecode
	\item Position inside bytecode
	\item Bytecode stack content
\end{itemize}

The position inside bytecode can be printed alongside with the bytecode~(we can re-use already implemented bytecode disassembler~\ref{implementation-of-disassembler}). For the second part, we already implemented the stack printer function.

\subsection{Main idea}

The main idea behind the debugger implementation is to maintain the same functionality and user interface as the current \textit{AST} implementation.

\subsection{Global design}

The idea used behind the debugger implementation is inspired by the JS V8 VM~(see~\ref{bcdebug-implementation-in-v8}). It is to replace the original instruction with the special breakpoint instruction together with saving~ the original instruction alongside the bytecode. The whole idea to make separate instruction and not the run-time check for debug flag would enable the dispatching of bytecode debug features with evaluating the same code while not causing any performance overhead in case the code is not debugged.

The bytecode debugger feature is by default disabled. Managing the state for enabling it is done by \textit{enableBCDebug} function~(written in \textit{src/main/debug.c}). This function is is internally handling a \code{R{\_}is{\_}bc{\_}debug{\_}enabled} variable. See the figure~\ref{fig:debugged-bcdebug-enabled} for example.

\begin{figure}[H]
\begin{lstlisting}
options(keep.source=TRUE)
library(compiler)
enableBCDebug(TRUE)

f<-function(a){
    c<-a+1
    d<-c+a
    c-d
}
compiled <- cmpfun(f)
debug(compiled)
compiled(2)
\end{lstlisting}
	\caption{Example of debugged function with bytecode debugger enabled}\label{fig:debugged-bcdebug-enabled}
\end{figure}

\subsection{Instruction for debugging}\label{instruction-for-debugging}

To be able to dispatch breakpoints there has been created a specific set of debug instructions. For dispatching breakpoint on the instruction, the original instruction is replaced with its equivalent~(according to the number of arguments) breakpoint one. The debugging instructions are:

\begin{itemize}
	\item \textbf{\code{BREAKPOINT0}}
	\item \textbf{\code{BREAKPOINT1}}
	\item \textbf{\code{BREAKPOINT2}}
	\item \textbf{\code{BREAKPOINT3}}
	\item \textbf{\code{BREAKPOINT4}}
\end{itemize}

The decision to make a separate instruction for each argument count was made because of simplicity and forward compatibility. Because the normal instruction is replaced with the debug one but as long as the debug instructions are for each number of the arguments we know the number of the arguments of the previous instruction. This knowledge would allow us to keep all of the functions iterating over the argument count intact.

\subsection{Storing of the original instruction when the breakpoint is set}\label{storing-original-instructions}

In case the breakpoint is set~(the breakpoint instruction overwrites the corresponding original one) we need to store the original instruction~(to keep the functionality of the evaluated function intact).

The idea begin implemented solution is to make a deep copy of unchanged code array to preserve the original instruction list. This copy is made the first change of the breakpoint~(first replacing with the breakpoint instruction) and attached to the \code{BCODESXP} by making new \code{CONS} cell. Once this is done, we can set or unset the breakpoint on any instruction without worrying about losing any information. The placing / removing of the breakpoint instruction is done in the \code{modifybcbreakpoint} function~(written in the \textit{src/main/main.c} file).

The internal representation of the \code{BCODESXP} memory object holding the GNU-R bytecode is the same as the \code{LISTSXP}~(the \code{BCODESXP} is internally wrapper over \code{LISTSXP}). The changes made by making an cons cell means that there is added one more nested layer. All of these functionality~(going through \code{BCODESXP} and \code{LISTSXP}) is already implemented in the Garbage Collector~(see~\ref{GC}), so there is no need to update it to support this change.

\subsection{Setting and removing debug instruction}\label{setting-and-unsetting-debug-instruction}

To be able to set~(and unset) the debug instruction on the bytecode there has been created a \code{bcSetBreakpoint} function inside \code{compiler} package~(see fig.~\ref{fig:bcsetbreakpoint-source} for source code). It has support for both setting and removing the breakpoint on instruction~(parameter \code{is}). It is returning the position of newly set instruction which is used in the setting next breakpoint~\ref{setting-next-breakpoint}. This returned position can be different than the position passed through the parameter. The reason behind this is that this function needs to be fail-proof. It means that it cannot break the code by modifying the argument instead of the instruction~(the function is exposed to the end-user). The way to solve is to implement finding of the first instruction which position~(index) is the first after the position given through \code{code} argument~(satisfies the \code{$>= code$} condition). Then the \code{bcSetBreakpoint} function can place the breakpoint to the founded position and return that position.

\begin{figure}[H]
\begin{lstlisting}
bcSetBreakpoint <- function(code, pos, is=TRUE) {
  if (typeof(code)=="closure")
    bc <- .Internal(bodyCode(code))
  else
    bc <- code
  if (typeof(bc)!="bytecode")
    stop("Internal error - code is not bytecode")

  bc <- .Internal(disassemble(bc))
  bcode <- bc[[2]]
  newbcode <- rep(bcode) #replicate original bytecode

  #loop through bytecode over instructions and find
  #   matching instruction
  setpos <- 2
  repeat{
    if(!(setpos < length(bcode) && setpos <= pos)) break
    setpos <- setpos + 1 + Opcodes.argc[[bcode[setpos]+1]]
  }

  .Internal(modifybcbreakpoint(code, setpos-1, is));

  setpos-1
}
\end{lstlisting}
	\caption{Source code of bcSetBreakpoint function}\label{fig:bcsetbreakpoint-source}
\end{figure}

\subsection{Listing breakpoints}\label{listing-breakpoints}

\begin{figure}[h]
\begin{lstlisting}
options(keep.source=TRUE)
library(compiler)
library(bctools)

f<-function(a){
    c<-a+1
    d<-c+ac
    c-d
}

compiled <- cmpfun(f)

#set breakpoints

 #this breakpoint would be set into position 12,
 # because at 11 is argument and
 # the implemented functionality is setting
 # the breakpoint in that cases
 # to the first following instruction
bcSetBreakpoint(compiled, 11);
 #14 is regular instruction
bcSetBreakpoint(compiled, 14);

#print the current function
# - notice the (BR) in the instruction
print(disassemble(compiled),verbose=2)

#print the bytecode instructions
# - see the 12 and 14
# -   returning an c(12,14) equivalent
print(bcListBreakpoints(compiled))
\end{lstlisting}
	\caption{Example usage of bcListBreakpoints function}\label{fig:bclistbreakpoints-example}
\end{figure}

To manage the breakpoint status, there has been implemented a \code{bcListBreakpoints} function~(implemented inside the \code{compiler} package). It is returning the array of the instruction positions which contains breakpoint~(see figure~\ref{fig:bclistbreakpoints-example} for usage example).

%TODO: move this somewhere to end

\subsection{Setting the next breakpoint}\label{setting-next-breakpoint}

The consequential instruction does not necessarily mean the following instruction right next to each other in the bytecode array~(due to labels - see~\ref{instruction-arguments-labels}). The breakpoint for the next instruction can be either one of these:

\begin{itemize}
	\item following in the bytecode array
	\item at the position where are the instruction labels pointing to~(see types of labels~\ref{instruction-arguments-labels})
\end{itemize}

The handling of this fact was implemented inside the\code{bcSetNextBreakpoint} function~(inside the \code{compiler} package). This function is also used inside the  \code{C} code in the debugger. To support easier dispatching it has been also written a \code{Rf{\_}breakOnNextBCInst} function which is internally dispatching a \code{bcSetNextBreakpoint} function by a call to the \code{R} code through \code{eval}.

The implementation of the \code{bcSetNextBreakpoint} function is checking all possible locations for the jump locations. It is also checking if there is already set a breakpoint in that position. If no, then it is setting there breakpoint instruction. For placing the breakpoint instruction it is using the internal call to the \code{C} function \code{modifybcbreakpoint}~(see~\ref{setting-and-unsetting-debug-instruction}).

It is also returning an array of newly added breakpoint locations. This feature is used in the implementation of the \code{BREAKPOINT} instruction~(see~\ref{implementation-of-breakpoint-instruction}) in the \code{C} core - this returned array is used to keep tracking of the added breakpoints.

\subsection{Support in the disassembly tool}\label{debugger-support-in-disassembly}

\begin{figure}[h]
\begin{lstlisting}
Bytecode ver. 10

 - #2: c<-a+1
  @ a
   1: GETVAR              a
  @ 1
   3: LDCONST             1
  @ a + 1
   5: ADD                 a + 1
  @ c <- a + 1
   7: SETVAR              c
   9: POP
 - #3: d<-c+a
  @ c
  10: GETVAR              c
  @ a
  12: (BR) GETVAR         a
  @ c + a
  14: ADD            c + a
  @ d <- c + a
  16: SETVAR              d
  18: POP
 - #4: c-d
  @ c
  19: GETVAR              c
  @ d
  21: GETVAR              d
  @ c - d
  23: SUB                 c - d
  25: RETURN
\end{lstlisting}
	\caption{Example of showing an instruction with breakpoint in the disassembly tool - (notice \code{GETVAR} instruction on position 12)}\label{fig:breakpoints-in-disassembly-example}
\end{figure}

There has been added support for visualizing the breakpoints set on the instruction into the disassembly tool. The R disassembly script was modified to get 3 arrays as a input~(added field with the original code array - see~\ref{storing-original-instructions}). The original array is returned every time no matter if the \code{BCODESXP} code array is modified or not~(in case not modified there is returned the same code array twice).

This means that we can just simply modify the disassembler to go always through the original array. Then for every instruction we would be checking in the code array~(which possibly contains breakpoints) if there is breakpoint or not. In case there is we would just simply print an mark \code{(BR)} as prefix for the instruction name to signalize that this instruction contains breakpoint~(see the figure~\ref{fig:breakpoints-in-disassembly-example} for example).

\subsection{Temporary and regular breakpoints}\label{temporary-and-regular-breakpoints}

Currently there are two types of the breakpoint inside the bytecode:

\begin{itemize}
	\item temporary breakpoint
	\item regular breakpoint
\end{itemize}

The regular ones are used for user-defined breakpoint, these ones are set by calling \code{bcSetBreakpoint} function~(from \code{compiler} package). Once the bytecode interpreter reaches them the breakpoint functionality is called and the R shows the debugger interface.

The temporary ones are used on the other hand for handling debugger commands. They are implemented with the same instruction except there are also held their locations on the bytecode local stack~(variable in which points global \code{R{\_}BCtmpBreakpoints}). This value contains an array in which each elements is representing the location of the currently set temporary breakpoint. These temporary breakpoints always point to the instruction succeeding current the evaluated one~(see~\ref{setting-next-breakpoint}).

In order to keep the garbage collector satisfied and because it is not possible to store the variable in the local protection stack~(through \code{PROTECT}/\code{UNPROTECT} function - see \ref{GC}) during \code{bcEval}, there has been dedicated one field on the bytecode stack for storing this array. The \code{R{\_}BCtmpBreakpoints} variable is then pointer~(\code{SEXP*} type) to this location. This design allows changing of this variable while modifying the bytecode body from the different evaluated context. Changing this array and not keeping an new one also reflects the fact that the modifications inside the bytecode code array are also made in-place by modifying this array.

\subsection{Implementation of the breakpoint instructions}\label{implementation-of-breakpoint-instruction}

The reason why there are implemented separate breakpoint instructions for each number of instruction arguments is its annotation. It allows us that breakpoint instruction would have the information of number of its arguments with itself. It would prevent from the breaking the bytecode code array structure. However the evaluated code inside all of the breakpoint instructions would be the same. This means that it can be simply generalized by writing single macro for all breakpoint instructions. This macro was decided to be named \code{DO{\_}BREAKPOINT} and it is containing this algorithm with the functionality for showing the debugger feature:

\begin{itemize}
	\item Remove all temporary breakpoints from the bytecode
	\item Print bytecode interpreter internal status (see~\ref{bytecode-interpreter-internal-status})
	\item Call debug browser
	\item Set \code{RDEBUG} debug flag~(see~\ref{handling-debugger-user-input})
	\item Call the original instruction~(see~\ref{threaded-and-non-threaded-design})
\end{itemize}

As you can see in the time of calling the browser there are all temporary breakpoints removed from the bytecode code array. It means that just the regular user-defined breakpoints~(see~\ref{temporary-and-regular-breakpoints}) would the printed to the output~(see~\ref{debugger-support-in-disassembly}). It is desired behavior because we do not want to print the user breakpoints which are used just for internal purposes of a step-by-step feature of the debugger~(see~\ref{handling-debugger-user-input}).

\subsection{Bytecode interpreter internal status}\label{bytecode-interpreter-internal-status}

Users need to know whether the interpreter is in the BC or in the AST mode. In order to achieve this, the \code{"debugBC"} string was put as a prefix in the each debugger step~(instead of \code{"debug"} in the AST evaluator).

Thing of importance while debugging the bytecode is the ability to locate the currently evaluated code~(position inside the code). For achieving this there has to be printed the internal status of the BC interpreter. This was implemented in two possible ways:

\begin{itemize}
	\item \textbf{Short compact way} inspired by AST status printing
	\item \textbf{Long verbose way} showing the all information available in the BC interpreter - used by default
\end{itemize}

To control whether to print out the short compact way or the long way the \code{R{\_}DebugVerbose} boolean variable is used. This flag is accessible for the user through the \code{debugVerbose()} function which acts as getter and setter altogether. It is returning the value of the variable as return value while having an optional parameter used for the modifying of the flag.

\subsubsection{The short compact way of status printing}\label{short-compact-way-of-status-printing}
It is used to simulate the AST printing behavior. It is printing the data in the same way as AST to remain the backward compatibility support~(for example for the debuggers in IDEs). This way is used by default.

\subsubsection{The long verbose way of showing all information}\label{long-verbose-way}
It is used for the printing of the whole internal state bytecode interpreter. To support this feature there has been implemented function \code{printBCStatus()}~(see the figure~\ref{fig:printbcstatus-code}).

\begin{figure}[H]
\begin{lstlisting}
void printBCStatus(){
    Rprintf("     --- Evaluating bytecode --- \n");
    R_printCurrentBCbody(R_BCbody, R_BCpc, TRUE, 1);
    Rprintf("     -------- Stack dump ------- \n");
    R_printCurrentBCstack(
    	R_BCNodeStackFnBase,
    	R_BCNodeStackTop);
}
\end{lstlisting}
	\caption{printBCStatus function for printing the whole BC status information}\label{fig:printbcstatus-code}
\end{figure}

As you can see the code is reusing the {bytecode disassembler~(see~\ref{implementation-of-disassembler}) and stack printer~(see~\ref{implementation-of-stack-printer}).

The bytecode disassembler function is printing the current bytecode instruction with the surrounding instructions~(\code{R{\_}printCurrentBCbody}. It is calling the bytecode  with the \code{select} parameter set to the selected instruction position~(to print out the \code{>>>} string) and the \code{peephole} argument set to \code{TRUE} to show just the surrounding instructions instead of the whole function~(current instruction and the 5 following ones).

\subsection{Debugger jumping granularity}\label{debugger-jumping-granuality}

The AST debugger is making one jump for every AST expression. The bytecode debugger, on the other hand, can jump in the much more granular way~(not according to the changes of expression references but one step for each bytecode instruction). Because the short compact way should be a simulation of the AST debugger it means that the debugger should also jump in similar way as the AST~(according to changes of expressions and not just by the bytecode instructions). This can be implemented in two ways:

\begin{itemize}
	\item calculate the next breakpoint location in the \code{bcSetNextBreakpoint}
	\item runtime checking by skipping the debug functionality in case the expression reference has not changed
\end{itemize}

The first way has better performance - the breakpoint would be placed on the right instruction where should be debugger functionality dispatched and there would be no runtime checking. The second one would work by placing the breakpoint instruction to the very next one while skipping the debugger functionality unless the change in expression reference occur~(runtime checking).

The runtime-checking was chosen due to implementation simplicity. The performance overhead would be only when the debugger is enabled which we are not worried in the first place.

\subsection{Handling of the recursive character of the bytecode}

The debugger implementation is modifying the breakpoint code by adding temporary breakpoint instructions~(see~\ref{setting-next-breakpoint}). This means that while calling recursive call there can be already set breakpoint instruction in the evaluated code. However, we do not want to have any of them executed in the recursive call of the function. To solve this there was done checking~(at the beginning of the \code{bcEval} function) whether the code is modified. If yes then we are creating a shallow copy of the current code without a modified bytecode code array by making new \code{BCODESXP} object created from an original code array and constant array~(see figure~\ref{fig:erase-breakpoints-in-bceval}).

Because of this implementation is allocating a new element we have to satisfy the language GC by putting its reference to the bytecode stack. It was decided to push the current evaluated body even when this change is not done. It is creating tiny memory overhead by having one unnecessary element on the stack but it is resulting in better code readability because of less conditions in the code.

\begin{figure}[H]
\begin{lstlisting}
/* duplicate body in case this
	function has modified */
if(BCODE_HAS_TMPBREAKPOINTS(body)){
  SEXP expr = TAG(body);
  body = CONS(
            BCODE_CODE_UNBREAKPOINT(body),
            BCODE_CONSTS(body));
  SET_TAG(body, expr);
  SET_TYPEOF(body, BCODESXP);
}

/* satisfy GC */
BCNPUSH(body); /* pushing body is neccesary
	just in case of duplicated, but pushing
	even unchanged one is easier for code
    readability */

\end{lstlisting}
	\caption{Modifying the bytecode array in the beginning of bcEval to erase breakpoints from the code}\label{fig:erase-breakpoints-in-bceval}
\end{figure}

\subsection{Threaded and non-threaded design of the application}\label{threaded-and-non-threaded-design}

Because of the speedup of the GNU-R evaluating there is support for the \code{THREADED} code~(see~\ref{Computed-GOTO}).

This means there were two different dispatch systems which had to be analyzed and modified to support the jumping to the different direction~(jump for calling the original instruction - inside the \textit{DO{\_}BREAKPOINT} macro).

\subsubsection{THREADED{\_}CODE defined}

In this case, the needed changes were minimal~(see figure~\ref{fig:instruction-handling-threaded}). It required adding a macro \code{BREAKPOINT{\_}GOTO{\_}ORIGIN{\_}OP} for a switching to the different instruction. In this case, the original bytecode instruction is represented with the location inside the code~(see~\ref{Computed-GOTO}) so the jump is being executed directly to that location.

\begin{figure}[H]
\begin{lstlisting}
#define NEXT() (__extension__ ({ \
    currentpc = pc; goto *(*pc++).v; \
    }))

#define BEGIN_MACHINE  NEXT();
    init: { loop: switch(which++)


#define BREAKPOINT_GOTO_ORIGIN_OP(inst) do{ \
    __extension__ ({goto *(*(inst)).v;}); \
  } while(0)
\end{lstlisting}
	\caption{Changes made for instruction handling macros in case \code{THREADED{\_}CODE} defined}\label{fig:instruction-handling-threaded}
\end{figure}

\subsubsection{THREADED{\_}CODE not defined}

In this situation, things are more complicated because the whole evaluator design is one big loop. The changes in this code were described in the figure~\ref{fig:instruction-handling-not-threaded}. The loop originally had one big switch~(its beginning is defined in \code{BEGIN{\_}MACHINE} macro) which was deciding which instruction to execute according to the value of operand~(\code{*op}). We changed this behavior so that it is loading operand~(\code{*op}) into a variable~(\code{jmp{\_}opcode}), then placed another jump label~(\code{do{\_}instruction}) and after that finally decided which instruction has to be evaluated according to the value of that variable~(by \code{switch} command). In the case of executing breakpoint instruction and evaluating original instruction~(jumping to another instruction through \code{BREAKPOINT{\_}GOTO{\_}ORIGIN{\_}OP}) we are setting the auxiliary variable \code{jmp{\_}opcode} to the desired instruction code and evaluating the switch statement for instruction~(jumping to the \code{jmp{\_}opcode} label).

\begin{figure}[H]
\begin{lstlisting}
#define NEXT() goto loop

#define BEGIN_MACHINE  loop: \
    currentpc = pc; \
    jmp_opcode = *pc++; \
    do_instruction: switch(jmp_opcode)

#define BREAKPOINT_GOTO_ORIGIN_OP(inst) do{ \
    jmp_opcode = *(inst); \
    goto do_instruction; \
  } while(0)
\end{lstlisting}
	\caption{Changes made for instruction handling macros in case \code{THREADED{\_}CODE} not defined}\label{fig:instruction-handling-not-threaded}
\end{figure}

\subsection{Handling of the debugger user input}\label{handling-debugger-user-input}

The original environment browser has inbuilt support for handling the debugging~(\textit{step into}, \textit{next step}, \textit{continue} etc.) via the user input~(see~\ref{handling-debugger-user-input}). It is managed by setting up the \code{RDEBUG} flag and the \code{R{\_}BrowserLastCommand} variable on the evaluated environment. The intent of implementing bytecode debugger interface was to reuse as much of this feature. It resulted in the fact that the bytecode debugger control is also managed through these variables. 

Bytecode interpreter also provides the more status information~(see~\ref{long-verbose-way}). It has been decided to extend the user interface to support showing these pieces of information by those commands~(see implementation in the figure~\ref{fig:implementation-of-bcstack-bc-commands}):

\begin{itemize}
	\item \code{bc} - print the current bytecode with marked the current evaluated position~(see~\ref{implementation-of-disassembler})
	\item \code{bcstack} - print current bytecode stack~(see~\ref{implementation-of-stack-printer})
\end{itemize}

\begin{figure}[H]
\begin{lstlisting}
...
other commands
...

}else if (!strcmp(expr, "bcstack")){
    rval = 2;
    RCNTXT* cntxt = GetBCDebugContext();
    if(R_BCIntActive)
        R_printCurrentBCstack(
            R_BCNodeStackFnBase,
            R_BCNodeStackTop);
    else
        Rprintf("Debugged context is not bytecode\n");
} else if (!strcmp(expr, "bc")) {
    rval = 2;
    RCNTXT* cntxt = GetBCDebugContext();
    if(R_BCIntActive)
        R_printCurrentBCbody(R_BCbody, R_BCpc, FALSE, 1);
    else
        Rprintf("Debugged context is not bytecode\n");
} else if () {
...
other commands
...
\end{lstlisting}
	\caption{Implemenation of \code{bcstack} and \code{bc} commands in the debugger interface}\label{fig:implementation-of-bcstack-bc-commands}
\end{figure}

\subsection{Entry points to the bcEval function}

While debugging bytecode, there are no runtime checks inside the \code{bcEval} function for the \code{RDEBUG} flag~(due to performance reasons - see~\ref{instruction-for-debugging}). Because of this and the nature of dispatching breakpoint functionality through the special \code{BREAKPOINT} instructions~(see~\ref{instruction-for-debugging}) there is need for setting the bytecode instruction~\ref{setting-next-breakpoint} to dispatch bytecode functionality. The modifying of the flag of the debugger functionality~(\code{RDEBUG}) means that we have to check and potentially apply the breakpoint instruction to the code every time the \code{RDEBUG} flag can be modified.

Currently, there are two places where this change can happen~(entry places into the \code{bcEval} function):

\begin{itemize}
	\item At the beginning of \code{bcEval} - the bytecode function was just called
	\item Inside \code{bcEval} at the positions of the return from the function calls
\end{itemize}

The first case is handled at the beginning of the bytecode evaluation function~(\code{bcEval} function). In this case, there is a call to the \code{Rf{\_}breakOnNextBCInst} which is setting the breakpoint to the first instruction.

The other entry point~(after the return from the function calls) would be used just because of the conditional breakpoints implementation~\ref{conditional-breakpoints}. If the debugger modified the state of the evaluated bytecode function~(the function was not in debug mode and now is due to calling breakpoint), add the debugging instruction to the next following instruction~(see~\ref{conditional-breakpoints}).

\section{Simulated conditional breakpoints}\label{conditional-breakpoints}

Due to lack of the ability of the simple and user-friendly conditional breakpoints, there has been put a decision to add support for simulating them. This feature was implemented via \code{breakpoint()} function which fires the debugger functionality on the spot. It allows the user to simulate conditional breakpoint behavior by calling the environment browser. This \code{breakpoint()}~(see fig. \ref{fig:example-of-conditional-breakpoints}) function is inspired by the JS \code{debugger;} command, but instead of being a separate command~(which would be big change in the language parser) it is a callable function.

As you can see in the figure~\ref{fig:conditional-breakpoints-breakpoint}, this function is modifying the \code{RDEBUG} flag of the currently evaluating environment and resetting the temporary bytecode variables (\code{R{\_}BrowserLastCommand} and \code{browserfinish} member of function context).

\begin{figure}[H]
\begin{lstlisting}
SEXP attribute_hidden do_breakpoint
	(SEXP call, SEXP op, SEXP args, SEXP rho)
{
  Rboolean oldrdebug;
  oldrdebug = RDEBUG(rho);
  SET_RDEBUG(rho, 1);
  R_GlobalContext->browserfinish = 0;
  R_BrowserLastCommand = 'n';


  if(!R_is_bc_debug_enabled() && R_BCIntActive)
    warning(_("Calling breakpoint in the BC

  while bytecode debugger disabled"));

  /* Support for bytecode debugger */
  if(R_BCIntActive && !oldrdebug){
    R_RemoveBCtmpBreakpoints(
      R_BCbody, *R_BCtmpBreakpoints);
    Rf_breakOnNextBCInst(
      R_BCbody, R_BCpc, R_BCtmpBreakpoints);
  }

  return R_NilValue;
}
\end{lstlisting}
	\caption{Implementation of simulated conditional breakpoints through breakpoint() function}\label{fig:conditional-breakpoints-breakpoint}\label{simulated-conditional-breakpoints}
\end{figure}

\begin{figure}[H]
\begin{lstlisting}
#setting up the bytecode
options(keep.source=TRUE)
debugVerbose(TRUE)
enableBCDebug(TRUE)
library(compiler)

#evaluated function with breakpoint fired
# once the x variable equals to 3
f<-function(){
  for(x in 1:5){
    if(x == 3){
      breakpoint();
    }
  }
}
compiled <- cmpfun(f)
compiled()
\end{lstlisting}
	\caption{Example usage of simulated conditional breakpoints through breakpoint() function}\label{fig:example-of-conditional-breakpoints}
\end{figure}

\chapter{Testing and future work}\label{testing-and-future-work}

There was done unit testing of the Bytecode disassembler~\ref{bytecode-disassembler-testing} alongside with the performance testing of the debugger implementation on the bytecode engine~\ref{performance-testing}.

\section{Bytecode disassembler}\label{bytecode-disassembler-testing}

The main part of the work was done as the separate GNU-R package \code{bctools}. The R package system has its test subsystem which runs every file in the \code{tests} directory and checks if it returns an error or not.

The test files of the \code{bctools} package include:
\begin{itemize}
	\item \textbf{basics.R} - basic functionality (printing the different cases - for loop, switch command, while loop etc.)
	\item \textbf{advanced.R} - advanced functionality
	\item \textbf{closure.R} - printing function closure
	\item \textbf{switch.R} - switch command
	\item \textbf{peephole.R} - peephole parameter
	\item \textbf{bcverbose.R} - verbose parameter
	\item \textbf{bcversion.R} - check if the current GNU-R BC version is the supported one in this package~(see~\ref{R-internal-bc-representation})
\end{itemize}

\section{Performance testing}\label{performance-testing}

There was done performance a performance testing to prove that the changes done in the GNU-R language bytecode evaluator did not caused any slowdown. The testing was done through the set of the micro-benchmarks executing the computationally expensive bytecode functions. 

Data were taken on the computer with these specifications~(the system was running just the test scripts one at the time):

\begin{itemize}
	\item Windows 10 Home - Ubuntu 16.04.4 Xenial subsystem
	\item Intel Core i7 8550u - 1.8GHz, 4 cores, 8 threads
	\item 512GB PCIe NVMe SSD
	\item 16GB RAM
\end{itemize}

The result~(see the fig.~\ref{fig:performance-testing}) showed just minimal fluctuations which are caused by inacurracy during the measuring. This means that there is no performance difference caused by implementation of the BC debugger.

\begin{figure}[H]\centering
	\includegraphics[width=\textwidth]{performance-testing}
	\caption{Performance testing}\label{fig:performance-testing}
\end{figure}

\section{Future work}

\subsection{Push into working repository}

The big part of the planned future part of the work is to collaborate with the GNU-R core team to push this thesis code into their development and potentially even the production code. After this would be done, and considering the number of people using GNU-R language~(the estimation in 2013 was approx 2 million), the work done in this thesis would have a significant worldwide effect to a lot of the people.

%TODO: ADD USAGE OF R IN REFERENCES

\subsection{Merging the bctools package into the compilers}

The \code{bctools} package was developed independently as add separate disassemble feature with the minimal changes to the GNU-R VM core. This tool was also used in the debugger which is part of the VM core. When the debugger would be deployed it is suggested to merge the \code{bctools} package into the \code{compiler} because the source code of the \code{bctools} package is short~(approx. 600 lines). The reason why this was not already done, but just proposed as a future work, is that it would allow to deploy the disassembler into the working branch faster and eventually give a user-feedback for improvements before merging inside the \code{compiler} package and deploying the debugger.

\subsection{Ability to print out values from the different environment}

The current implementation of bytecode function print / stack print inside debugger is reflecting the nature of evaluation browser which is evaluating expressions on the currently evaluated environment. This is restricting user to show the bytecode content of the parent calls. 

It can be solved either as:
\begin{itemize}
	\item Adding the additional argument specifying the stack frame 
	\item Adding the ability to switch the stack frames ( like \code{fr} command of the \code{gdb} debugger )
\end{itemize}

The easiest solution to implement is the first one. On the other side even the parent environments could have expressions which can be shadowed. The second \code{fr} feature would enable user to show not just bytecode but also the expressions from any environment in the stack trace.

\subsection{GNU-R Memory optimization}

Some of the parts of the errors which were done and fixed during the development of this thesis were memory-based. During an investigation of these errors, there has been noticed one thing. The core of the GNU-R language is heavily dependent on the linked list memory data structure. Because of the modern computer memory system cache implementation~\cite{processor-cache}, this can cause a lot of memory cache misses which affect the performance. The most straightforward way to do this is to use a \code{smallvector} technique~(inspired by a llvm compiler), but the more appropriate way would be to do analysis of whole GNU-R memory subsystem optimization with focus on cache locality.

\setsecnumdepth{part}
\begin{conclusion}\label{conclusion}

The GNU-R language is one of the most popular scientific language used worldwide~(not just by the scientific community). For better evaluation performance its VM internally supports the bytecode alongside the slow AST interpreter. Since currently there is a limited option for debugging the bytecode, the old disassembler showed only the raw array of instructions with the constant buffer, and there was no implementation of bytecode debugging. Instead of bytecode debugging, the evaluator was internally dispatching the AST debugger, which technically resulted in the fact that the interpreter was going over the different code while debugging. The purpose of this thesis was to analyze these issues, propose a change, and write the implementation of these features.

This thesis has proposed an implementation of changes to solve the issues outlined above. They contain the user-friendly and less jargon-heavy bytecode disassembler~\ref{implementation-of-disassembler}, native debugger support for bytecode evaluator~\ref{implementation-of-debugger}, and as an additional feature has been added the \code{breakpoint()} function that enables simulation of the conditional breakpoint~\ref{simulated-conditional-breakpoints}. The performance testing showed that these implemented features have no negative performance effects on the language speed.

The structure of this work is as follows. In the beginning, there is a brief introduction and rationale of the proposed problem~\ref{introduction}. Followed by the analysis of the current implementation of the GNU-R bytecode disassembler~\ref{analysis-of-disassembler} and debugger~\ref{analysis-of-debugger} alongside the comparison of similar tools and features in VMs of other languages, after that details of the implementation are described. This begins with an implementation of the disassembler~\ref{implementation-of-disassembler} followed by the stack printer tool~\ref{implementation-of-stack-printer}. After that, there is a description of the debugger implementation~\ref{implementation-of-debugger} where it is shown that we reused two previously implemented features~(the disassembler and the stack printer). Also, the implementation of simulated conditional breakpoints is described~\ref{conditional-breakpoints}. The work is concluded with a chapter about the testing of all features~\ref{performance-testing} and closes with possible future work and improvements~\ref{testing-and-future-work}.

All the features were developed and tested and are included on the enclosed DVD. The work has also been published on the GitHub~(\cite{R_WITH_BC_DEBUGGER} and \cite{R_BC_DISASSEMBLER}).

Personally, it was an excellent experience to work on the real language VM while implementing features which millions of people would use. The work performed in this thesis can be considered a success.

\end{conclusion}


\bibliographystyle{iso690.bst}
\nocite{*}
\bibliography{bibliography}

%\setsecnumdepth{all}
\appendix

\chapter{Acronyms}
% \printglossaries
\begin{description}
	\item[VM] Virtual Machine
	\item[BC] Bytecode
	\item[GC] Garbage collector
	\item[AST] Abstract syntax tree
	\item[IR] Intermediate representation
	\item[JS] JavaScript
	\item[OO] Object oriented
	\item[OOP] Object oriented programming
	\item[JIT] Just in time
	\item[REPL] Read-Eval-Print-Loop
	\item[UI] User interface
	\item[ARM] Advanced RISC Machine, originally Acorn RISC Machine
	\item[CRAN] The Comprehensive R Archive Network
	\item[GCC] GNU Compiler Collection
	\item[TDD] Test driven development
\end{description}


\chapter{Contents of enclosed DVD}

%change appropriately

\begin{figure}
	\dirtree{%
		.1 readme.txt\DTcomment{instruction for the file}.
		.1 analysis\DTcomment{analysis of other implementations}.
		.1 examples\DTcomment{implementation examples directory}.
		.2 cond{\_}breakpoint\DTcomment{simulated conditional breakpoint examples directory}.
		.2 r{\_}breakpoints\DTcomment{bytecode debugger examples directory}.
		.2 r{\_}disassembly\DTcomment{bytecode disassembler examples directory}.
		.1 noncomplete{\_}functions\DTcomment{analysis of other implementations}.
		.1 bctools\DTcomment{the bctools package directory}.
		.1 r{\_}src\DTcomment{modified GNU-R source}.
		.1 thesis\DTcomment{the thesis source code directory}.
		.2 DP{\_}Saska{\_}Ales{\_}2018.pdf\DTcomment{the thesis text in PDF format}.
		.2 DP{\_}Saska{\_}Ales{\_}.tex\DTcomment{the thesis text in \LaTeX{} format}.
	}
\end{figure}

\end{document}
