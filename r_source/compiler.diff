Index: src/library/compiler/NAMESPACE
===================================================================
--- src/library/compiler/NAMESPACE	(revision 72147)
+++ src/library/compiler/NAMESPACE	(working copy)
@@ -1,4 +1,4 @@
-export(cmpfun,cmpfile,loadcmp,compile,disassemble)
+export(cmpfun,cmpfile,loadcmp,compile,disassemble,bcinfo)
 export(enableJIT,compilePKGS)
 export(getCompilerOption,setCompilerOptions)
 
Index: src/library/compiler/R/cmp.R
===================================================================
--- src/library/compiler/R/cmp.R	(revision 72147)
+++ src/library/compiler/R/cmp.R	(working copy)
@@ -508,133 +508,144 @@
 ## Opcode constants
 ##
 
-Opcodes.argc <- list(
-BCMISMATCH.OP = 0,
-RETURN.OP = 0,
-GOTO.OP = 1,
-BRIFNOT.OP = 2,
-POP.OP = 0,
-DUP.OP = 0,
-PRINTVALUE.OP = 0,
-STARTLOOPCNTXT.OP = 2,
-ENDLOOPCNTXT.OP = 1,
-DOLOOPNEXT.OP = 0,
-DOLOOPBREAK.OP = 0,
-STARTFOR.OP = 3,
-STEPFOR.OP = 1,
-ENDFOR.OP = 0,
-SETLOOPVAL.OP = 0,
-INVISIBLE.OP = 0,
-LDCONST.OP = 1,
-LDNULL.OP = 0,
-LDTRUE.OP = 0,
-LDFALSE.OP = 0,
-GETVAR.OP = 1,
-DDVAL.OP = 1,
-SETVAR.OP = 1,
-GETFUN.OP = 1,
-GETGLOBFUN.OP = 1,
-GETSYMFUN.OP = 1,
-GETBUILTIN.OP = 1,
-GETINTLBUILTIN.OP = 1,
-CHECKFUN.OP = 0,
-MAKEPROM.OP = 1,
-DOMISSING.OP = 0,
-SETTAG.OP = 1,
-DODOTS.OP = 0,
-PUSHARG.OP = 0,
-PUSHCONSTARG.OP = 1,
-PUSHNULLARG.OP = 0,
-PUSHTRUEARG.OP = 0,
-PUSHFALSEARG.OP = 0,
-CALL.OP = 1,
-CALLBUILTIN.OP = 1,
-CALLSPECIAL.OP = 1,
-MAKECLOSURE.OP = 1,
-UMINUS.OP = 1,
-UPLUS.OP = 1,
-ADD.OP = 1,
-SUB.OP = 1,
-MUL.OP = 1,
-DIV.OP = 1,
-EXPT.OP = 1,
-SQRT.OP = 1,
-EXP.OP = 1,
-EQ.OP = 1,
-NE.OP = 1,
-LT.OP = 1,
-LE.OP = 1,
-GE.OP = 1,
-GT.OP = 1,
-AND.OP = 1,
-OR.OP = 1,
-NOT.OP = 1,
-DOTSERR.OP = 0,
-STARTASSIGN.OP = 1,
-ENDASSIGN.OP = 1,
-STARTSUBSET.OP = 2,
-DFLTSUBSET.OP = 0,
-STARTSUBASSIGN.OP = 2,
-DFLTSUBASSIGN.OP = 0,
-STARTC.OP = 2,
-DFLTC.OP = 0,
-STARTSUBSET2.OP = 2,
-DFLTSUBSET2.OP = 0,
-STARTSUBASSIGN2.OP = 2,
-DFLTSUBASSIGN2.OP = 0,
-DOLLAR.OP = 2,
-DOLLARGETS.OP = 2,
-ISNULL.OP = 0,
-ISLOGICAL.OP = 0,
-ISINTEGER.OP = 0,
-ISDOUBLE.OP = 0,
-ISCOMPLEX.OP = 0,
-ISCHARACTER.OP = 0,
-ISSYMBOL.OP = 0,
-ISOBJECT.OP = 0,
-ISNUMERIC.OP = 0,
-VECSUBSET.OP = 1,
-MATSUBSET.OP = 1,
-VECSUBASSIGN.OP = 1,
-MATSUBASSIGN.OP = 1,
-AND1ST.OP = 2,
-AND2ND.OP = 1,
-OR1ST.OP = 2,
-OR2ND.OP = 1,
-GETVAR_MISSOK.OP = 1,
-DDVAL_MISSOK.OP = 1,
-VISIBLE.OP = 0,
-SETVAR2.OP = 1,
-STARTASSIGN2.OP = 1,
-ENDASSIGN2.OP = 1,
-SETTER_CALL.OP = 2,
-GETTER_CALL.OP = 1,
-SWAP.OP = 0,
-DUP2ND.OP = 0,
-SWITCH.OP = 4,
-RETURNJMP.OP = 0,
-STARTSUBSET_N.OP = 2,
-STARTSUBASSIGN_N.OP = 2,
-VECSUBSET2.OP = 1,
-MATSUBSET2.OP = 1,
-VECSUBASSIGN2.OP = 1,
-MATSUBASSIGN2.OP = 1,
-STARTSUBSET2_N.OP = 2,
-STARTSUBASSIGN2_N.OP = 2,
-SUBSET_N.OP = 2,
-SUBSET2_N.OP = 2,
-SUBASSIGN_N.OP = 2,
-SUBASSIGN2_N.OP = 2,
-LOG.OP = 1,
-LOGBASE.OP = 1,
-MATH1.OP = 2,
-DOTCALL.OP = 2,
-COLON.OP = 1,
-SEQALONG.OP = 1,
-SEQLEN.OP = 1,
-BASEGUARD.OP = 2
+
+SKIP.ARGTYPE<--1
+LABEL.ARGTYPE<-0
+CONSTANTS.ARGTYPE<-3
+CONSTANTS_DBG.ARGTYPE<-4
+BOOL.ARGTYPE<-11
+INT.ARGTYPE<-10
+
+Opcodes.argdescr <- list(
+
+BCMISMATCH.OP = c(),
+RETURN.OP = c(),
+GOTO.OP = c(LABEL.ARGTYPE),
+BRIFNOT.OP = c(CONSTANTS.ARGTYPE,LABEL.ARGTYPE),
+POP.OP = c(),
+DUP.OP = c(),
+PRINTVALUE.OP = c(),
+STARTLOOPCNTXT.OP = c(BOOL.ARGTYPE, LABEL.ARGTYPE),#  bool is_for_loop, pc for break
+ENDLOOPCNTXT.OP = c(BOOL.ARGTYPE),
+DOLOOPNEXT.OP = c(),
+DOLOOPBREAK.OP = c(),
+STARTFOR.OP = c(CONSTANTS_DBG.ARGTYPE, CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+STEPFOR.OP = c(LABEL.ARGTYPE),
+ENDFOR.OP = c(),
+SETLOOPVAL.OP = c(),
+INVISIBLE.OP = c(),
+LDCONST.OP = c(CONSTANTS.ARGTYPE),
+LDNULL.OP = c(),
+LDTRUE.OP = c(),
+LDFALSE.OP = c(),
+GETVAR.OP = c(CONSTANTS.ARGTYPE),
+DDVAL.OP = c(CONSTANTS.ARGTYPE),
+SETVAR.OP = c(CONSTANTS.ARGTYPE),
+GETFUN.OP = c(CONSTANTS.ARGTYPE),
+GETGLOBFUN.OP = c(CONSTANTS.ARGTYPE),
+GETSYMFUN.OP = c(CONSTANTS.ARGTYPE),
+GETBUILTIN.OP = c(CONSTANTS.ARGTYPE),
+GETINTLBUILTIN.OP = c(CONSTANTS.ARGTYPE),
+CHECKFUN.OP = c(),
+MAKEPROM.OP = c(CONSTANTS.ARGTYPE),
+DOMISSING.OP = c(),
+SETTAG.OP = c(CONSTANTS.ARGTYPE),
+DODOTS.OP = c(),
+PUSHARG.OP = c(),
+PUSHCONSTARG.OP = c(CONSTANTS.ARGTYPE),
+PUSHNULLARG.OP = c(),
+PUSHTRUEARG.OP = c(),
+PUSHFALSEARG.OP = c(),
+CALL.OP = c(CONSTANTS.ARGTYPE),
+CALLBUILTIN.OP = c(CONSTANTS.ARGTYPE),
+CALLSPECIAL.OP = c(CONSTANTS.ARGTYPE),
+MAKECLOSURE.OP = c(CONSTANTS.ARGTYPE),
+UMINUS.OP = c(CONSTANTS_DBG.ARGTYPE),
+UPLUS.OP = c(CONSTANTS_DBG.ARGTYPE),
+ADD.OP = c(CONSTANTS_DBG.ARGTYPE),
+SUB.OP = c(CONSTANTS_DBG.ARGTYPE),
+MUL.OP = c(CONSTANTS_DBG.ARGTYPE),
+DIV.OP = c(CONSTANTS_DBG.ARGTYPE),
+EXPT.OP = c(CONSTANTS_DBG.ARGTYPE),
+SQRT.OP = c(CONSTANTS_DBG.ARGTYPE),
+EXP.OP = c(CONSTANTS_DBG.ARGTYPE),
+EQ.OP = c(CONSTANTS_DBG.ARGTYPE),
+NE.OP = c(CONSTANTS_DBG.ARGTYPE),
+LT.OP = c(CONSTANTS_DBG.ARGTYPE),
+LE.OP = c(CONSTANTS_DBG.ARGTYPE),
+GE.OP = c(CONSTANTS_DBG.ARGTYPE),
+GT.OP = c(CONSTANTS_DBG.ARGTYPE),
+AND.OP = c(CONSTANTS_DBG.ARGTYPE),
+OR.OP = c(CONSTANTS_DBG.ARGTYPE),
+NOT.OP = c(CONSTANTS_DBG.ARGTYPE),
+DOTSERR.OP = c(),
+STARTASSIGN.OP = c(CONSTANTS.ARGTYPE),
+ENDASSIGN.OP = c(CONSTANTS.ARGTYPE),
+STARTSUBSET.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+DFLTSUBSET.OP = c(),
+STARTSUBASSIGN.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+DFLTSUBASSIGN.OP = c(),
+STARTC.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+DFLTC.OP = c(),
+STARTSUBSET2.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+DFLTSUBSET2.OP = c(),
+STARTSUBASSIGN2.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+DFLTSUBASSIGN2.OP = c(),
+DOLLAR.OP = c(CONSTANTS.ARGTYPE, CONSTANTS.ARGTYPE),
+DOLLARGETS.OP = c(CONSTANTS.ARGTYPE, CONSTANTS.ARGTYPE),
+ISNULL.OP = c(),
+ISLOGICAL.OP = c(),
+ISINTEGER.OP = c(),
+ISDOUBLE.OP = c(),
+ISCOMPLEX.OP = c(),
+ISCHARACTER.OP = c(),
+ISSYMBOL.OP = c(),
+ISOBJECT.OP = c(),
+ISNUMERIC.OP = c(),
+VECSUBSET.OP = c(CONSTANTS.ARGTYPE),
+MATSUBSET.OP = c(CONSTANTS.ARGTYPE),
+VECSUBASSIGN.OP = c(CONSTANTS.ARGTYPE),
+MATSUBASSIGN.OP = c(CONSTANTS.ARGTYPE),
+AND1ST.OP = c(CONSTANTS_DBG.ARGTYPE, LABEL.ARGTYPE),
+AND2ND.OP = c(CONSTANTS_DBG.ARGTYPE),
+OR1ST.OP = c(CONSTANTS_DBG.ARGTYPE, LABEL.ARGTYPE),
+OR2ND.OP = c(CONSTANTS_DBG.ARGTYPE),
+GETVAR_MISSOK.OP = c(CONSTANTS.ARGTYPE),
+DDVAL_MISSOK.OP = c(CONSTANTS.ARGTYPE),
+VISIBLE.OP = c(),
+SETVAR2.OP = c(CONSTANTS.ARGTYPE),
+STARTASSIGN2.OP = c(CONSTANTS.ARGTYPE),
+ENDASSIGN2.OP = c(CONSTANTS.ARGTYPE),
+SETTER_CALL.OP = c(CONSTANTS.ARGTYPE, CONSTANTS.ARGTYPE),
+GETTER_CALL.OP = c(CONSTANTS.ARGTYPE),
+SWAP.OP = c(),
+DUP2ND.OP = c(),
+SWITCH.OP = c(CONSTANTS.ARGTYPE, CONSTANTS.ARGTYPE, CONSTANTS.ARGTYPE, CONSTANTS.ARGTYPE),
+RETURNJMP.OP = c(),
+STARTSUBSET_N.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+STARTSUBASSIGN_N.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+VECSUBSET2.OP = c(CONSTANTS.ARGTYPE),
+MATSUBSET2.OP = c(CONSTANTS.ARGTYPE),
+VECSUBASSIGN2.OP = c(CONSTANTS.ARGTYPE),
+MATSUBASSIGN2.OP = c(CONSTANTS.ARGTYPE),
+STARTSUBSET2_N.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+STARTSUBASSIGN2_N.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+SUBSET_N.OP = c(CONSTANTS.ARGTYPE, INT.ARGTYPE),
+SUBSET2_N.OP = c(CONSTANTS.ARGTYPE, INT.ARGTYPE),
+SUBASSIGN_N.OP = c(CONSTANTS.ARGTYPE, INT.ARGTYPE),
+SUBASSIGN2_N.OP = c(CONSTANTS.ARGTYPE, INT.ARGTYPE),
+LOG.OP = c(CONSTANTS.ARGTYPE),
+LOGBASE.OP = c(CONSTANTS.ARGTYPE),
+MATH1.OP = c(CONSTANTS.ARGTYPE, INT.ARGTYPE), #second argument is one of the math1funs
+DOTCALL.OP = c(CONSTANTS.ARGTYPE, INT.ARGTYPE),
+COLON.OP = c(SKIP.ARGTYPE),
+SEQALONG.OP = c(SKIP.ARGTYPE),
+SEQLEN.OP = c(SKIP.ARGTYPE),
+BASEGUARD.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE)
 )
 
+Opcodes.argc <- lapply(Opcodes.argdescr, length)
+
 Opcodes.names <- names(Opcodes.argc)
 
 BCMISMATCH.OP <- 0
@@ -3155,10 +3166,36 @@
         if (typeof(code) != "bytecode")
             stop("function is not compiled")
     }
-    dput(disasm(.Internal(disassemble(code))))
+    d <- disasm(.Internal(disassemble(code)))
+    class(d) <- "disassembly"
+    d
 }
 
+bcinfo <- function() {
+ 
+    operands <- setNames(
+                    lapply(
+                        Opcodes.names,
+                        function(x){ get(x, envir=environment(bcinfo)) }
+                    ), 
+                    Opcodes.names
+                )
 
+    list(
+        Argtypes=list(
+            SKIP=SKIP.ARGTYPE,
+            LABEL=LABEL.ARGTYPE,
+            CONSTANT=CONSTANTS.ARGTYPE,
+            CONSTANT_DBG=CONSTANTS_DBG.ARGTYPE,
+            BOOL=BOOL.ARGTYPE,
+            INT=INT.ARGTYPE
+        ),
+        Arguments=Opcodes.argdescr,
+        Operands=operands
+    )
+}
+
+
 ##
 ## Experimental Utilities
 ##
Index: src/library/compiler/noweb/compiler.nw
===================================================================
--- src/library/compiler/noweb/compiler.nw	(revision 72147)
+++ src/library/compiler/noweb/compiler.nw	(working copy)
@@ -5218,12 +5218,41 @@
 }
 @ %def checkCompilerOptions
 
+\subsection{Bytecode info}
+Infomation about bytecode is provided by [[bcinfo]]. 
+This is useful to get definition all instrutions numbers, and their arguments.
+<<[[bcinfo]] function>>=
+bcinfo <- function() {
+ 
+    operands <- setNames(
+                    lapply(
+                        Opcodes.names,
+                        function(x){ get(x, envir=environment(bcinfo)) }
+                    ), 
+                    Opcodes.names
+                )
 
+    list(
+        Argtypes=list(
+            SKIP=SKIP.ARGTYPE,
+            LABEL=LABEL.ARGTYPE,
+            CONSTANT=CONSTANTS.ARGTYPE,
+            CONSTANT_DBG=CONSTANTS_DBG.ARGTYPE,
+            BOOL=BOOL.ARGTYPE,
+            INT=INT.ARGTYPE
+        ),
+        Arguments=Opcodes.argdescr,
+        Operands=operands
+    )
+}
+@ %def bcinfo
+
 \subsection{Disassembler}
 A minimal disassembler is provided by [[disassemble]]. This is
-primarily useful for debugging the compiler.  A more readable output
-representation might be nice to have. It would also probably make
-sense to give the result a class and write a print method.
+primarily useful for debugging the compiler. It returns parsed 
+internal representation of bytecode with class "disassembly".
+The print method for this class which is implemented in the 
+bctools package.
 <<[[disassemble]] function>>=
 disassemble <- function(code) {
     .CodeSym <- as.name(".Code")
@@ -5240,7 +5269,9 @@
         if (typeof(code) != "bytecode")
             stop("function is not compiled")
     }
-    dput(disasm(.Internal(disassemble(code))))
+    d <- disasm(.Internal(disassemble(code)))
+    class(d) <- "disassembly"
+    d
 }
 @ %def disassemble
 
@@ -5966,136 +5997,150 @@
 BASEGUARD.OP <- 123
 @ 
 
-\subsection{Instruction argument counts and names}
-<<opcode argument counts>>=
-Opcodes.argc <- list(
-BCMISMATCH.OP = 0,
-RETURN.OP = 0,
-GOTO.OP = 1,
-BRIFNOT.OP = 2,
-POP.OP = 0,
-DUP.OP = 0,
-PRINTVALUE.OP = 0,
-STARTLOOPCNTXT.OP = 2,
-ENDLOOPCNTXT.OP = 1,
-DOLOOPNEXT.OP = 0,
-DOLOOPBREAK.OP = 0,
-STARTFOR.OP = 3,
-STEPFOR.OP = 1,
-ENDFOR.OP = 0,
-SETLOOPVAL.OP = 0,
-INVISIBLE.OP = 0,
-LDCONST.OP = 1,
-LDNULL.OP = 0,
-LDTRUE.OP = 0,
-LDFALSE.OP = 0,
-GETVAR.OP = 1,
-DDVAL.OP = 1,
-SETVAR.OP = 1,
-GETFUN.OP = 1,
-GETGLOBFUN.OP = 1,
-GETSYMFUN.OP = 1,
-GETBUILTIN.OP = 1,
-GETINTLBUILTIN.OP = 1,
-CHECKFUN.OP = 0,
-MAKEPROM.OP = 1,
-DOMISSING.OP = 0,
-SETTAG.OP = 1,
-DODOTS.OP = 0,
-PUSHARG.OP = 0,
-PUSHCONSTARG.OP = 1,
-PUSHNULLARG.OP = 0,
-PUSHTRUEARG.OP = 0,
-PUSHFALSEARG.OP = 0,
-CALL.OP = 1,
-CALLBUILTIN.OP = 1,
-CALLSPECIAL.OP = 1,
-MAKECLOSURE.OP = 1,
-UMINUS.OP = 1,
-UPLUS.OP = 1,
-ADD.OP = 1,
-SUB.OP = 1,
-MUL.OP = 1,
-DIV.OP = 1,
-EXPT.OP = 1,
-SQRT.OP = 1,
-EXP.OP = 1,
-EQ.OP = 1,
-NE.OP = 1,
-LT.OP = 1,
-LE.OP = 1,
-GE.OP = 1,
-GT.OP = 1,
-AND.OP = 1,
-OR.OP = 1,
-NOT.OP = 1,
-DOTSERR.OP = 0,
-STARTASSIGN.OP = 1,
-ENDASSIGN.OP = 1,
-STARTSUBSET.OP = 2,
-DFLTSUBSET.OP = 0,
-STARTSUBASSIGN.OP = 2,
-DFLTSUBASSIGN.OP = 0,
-STARTC.OP = 2,
-DFLTC.OP = 0,
-STARTSUBSET2.OP = 2,
-DFLTSUBSET2.OP = 0,
-STARTSUBASSIGN2.OP = 2,
-DFLTSUBASSIGN2.OP = 0,
-DOLLAR.OP = 2,
-DOLLARGETS.OP = 2,
-ISNULL.OP = 0,
-ISLOGICAL.OP = 0,
-ISINTEGER.OP = 0,
-ISDOUBLE.OP = 0,
-ISCOMPLEX.OP = 0,
-ISCHARACTER.OP = 0,
-ISSYMBOL.OP = 0,
-ISOBJECT.OP = 0,
-ISNUMERIC.OP = 0,
-VECSUBSET.OP = 1,
-MATSUBSET.OP = 1,
-VECSUBASSIGN.OP = 1,
-MATSUBASSIGN.OP = 1,
-AND1ST.OP = 2,
-AND2ND.OP = 1,
-OR1ST.OP = 2,
-OR2ND.OP = 1,
-GETVAR_MISSOK.OP = 1,
-DDVAL_MISSOK.OP = 1,
-VISIBLE.OP = 0,
-SETVAR2.OP = 1,
-STARTASSIGN2.OP = 1,
-ENDASSIGN2.OP = 1,
-SETTER_CALL.OP = 2,
-GETTER_CALL.OP = 1,
-SWAP.OP = 0,
-DUP2ND.OP = 0,
-SWITCH.OP = 4,
-RETURNJMP.OP = 0,
-STARTSUBSET_N.OP = 2,
-STARTSUBASSIGN_N.OP = 2,
-VECSUBSET2.OP = 1,
-MATSUBSET2.OP = 1,
-VECSUBASSIGN2.OP = 1,
-MATSUBASSIGN2.OP = 1,
-STARTSUBSET2_N.OP = 2,
-STARTSUBASSIGN2_N.OP = 2,
-SUBSET_N.OP = 2,
-SUBSET2_N.OP = 2,
-SUBASSIGN_N.OP = 2,
-SUBASSIGN2_N.OP = 2,
-LOG.OP = 1,
-LOGBASE.OP = 1,
-MATH1.OP = 2,
-DOTCALL.OP = 2,
-COLON.OP = 1,
-SEQALONG.OP = 1,
-SEQLEN.OP = 1,
-BASEGUARD.OP = 2
+\subsection{Instruction argument description and count}
+<<opcode argument description>>=
+
+SKIP.ARGTYPE<--1
+LABEL.ARGTYPE<-0
+CONSTANTS.ARGTYPE<-3
+CONSTANTS_DBG.ARGTYPE<-4
+BOOL.ARGTYPE<-11
+INT.ARGTYPE<-10
+
+Opcodes.argdescr <- list(
+
+BCMISMATCH.OP = c(),
+RETURN.OP = c(),
+GOTO.OP = c(LABEL.ARGTYPE),
+BRIFNOT.OP = c(CONSTANTS.ARGTYPE,LABEL.ARGTYPE),
+POP.OP = c(),
+DUP.OP = c(),
+PRINTVALUE.OP = c(),
+STARTLOOPCNTXT.OP = c(BOOL.ARGTYPE, LABEL.ARGTYPE),#  bool is_for_loop, pc for break
+ENDLOOPCNTXT.OP = c(BOOL.ARGTYPE),
+DOLOOPNEXT.OP = c(),
+DOLOOPBREAK.OP = c(),
+STARTFOR.OP = c(CONSTANTS_DBG.ARGTYPE, CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+STEPFOR.OP = c(LABEL.ARGTYPE),
+ENDFOR.OP = c(),
+SETLOOPVAL.OP = c(),
+INVISIBLE.OP = c(),
+LDCONST.OP = c(CONSTANTS.ARGTYPE),
+LDNULL.OP = c(),
+LDTRUE.OP = c(),
+LDFALSE.OP = c(),
+GETVAR.OP = c(CONSTANTS.ARGTYPE),
+DDVAL.OP = c(CONSTANTS.ARGTYPE),
+SETVAR.OP = c(CONSTANTS.ARGTYPE),
+GETFUN.OP = c(CONSTANTS.ARGTYPE),
+GETGLOBFUN.OP = c(CONSTANTS.ARGTYPE),
+GETSYMFUN.OP = c(CONSTANTS.ARGTYPE),
+GETBUILTIN.OP = c(CONSTANTS.ARGTYPE),
+GETINTLBUILTIN.OP = c(CONSTANTS.ARGTYPE),
+CHECKFUN.OP = c(),
+MAKEPROM.OP = c(CONSTANTS.ARGTYPE),
+DOMISSING.OP = c(),
+SETTAG.OP = c(CONSTANTS.ARGTYPE),
+DODOTS.OP = c(),
+PUSHARG.OP = c(),
+PUSHCONSTARG.OP = c(CONSTANTS.ARGTYPE),
+PUSHNULLARG.OP = c(),
+PUSHTRUEARG.OP = c(),
+PUSHFALSEARG.OP = c(),
+CALL.OP = c(CONSTANTS.ARGTYPE),
+CALLBUILTIN.OP = c(CONSTANTS.ARGTYPE),
+CALLSPECIAL.OP = c(CONSTANTS.ARGTYPE),
+MAKECLOSURE.OP = c(CONSTANTS.ARGTYPE),
+UMINUS.OP = c(CONSTANTS_DBG.ARGTYPE),
+UPLUS.OP = c(CONSTANTS_DBG.ARGTYPE),
+ADD.OP = c(CONSTANTS_DBG.ARGTYPE),
+SUB.OP = c(CONSTANTS_DBG.ARGTYPE),
+MUL.OP = c(CONSTANTS_DBG.ARGTYPE),
+DIV.OP = c(CONSTANTS_DBG.ARGTYPE),
+EXPT.OP = c(CONSTANTS_DBG.ARGTYPE),
+SQRT.OP = c(CONSTANTS_DBG.ARGTYPE),
+EXP.OP = c(CONSTANTS_DBG.ARGTYPE),
+EQ.OP = c(CONSTANTS_DBG.ARGTYPE),
+NE.OP = c(CONSTANTS_DBG.ARGTYPE),
+LT.OP = c(CONSTANTS_DBG.ARGTYPE),
+LE.OP = c(CONSTANTS_DBG.ARGTYPE),
+GE.OP = c(CONSTANTS_DBG.ARGTYPE),
+GT.OP = c(CONSTANTS_DBG.ARGTYPE),
+AND.OP = c(CONSTANTS_DBG.ARGTYPE),
+OR.OP = c(CONSTANTS_DBG.ARGTYPE),
+NOT.OP = c(CONSTANTS_DBG.ARGTYPE),
+DOTSERR.OP = c(),
+STARTASSIGN.OP = c(CONSTANTS.ARGTYPE),
+ENDASSIGN.OP = c(CONSTANTS.ARGTYPE),
+STARTSUBSET.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+DFLTSUBSET.OP = c(),
+STARTSUBASSIGN.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+DFLTSUBASSIGN.OP = c(),
+STARTC.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+DFLTC.OP = c(),
+STARTSUBSET2.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+DFLTSUBSET2.OP = c(),
+STARTSUBASSIGN2.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+DFLTSUBASSIGN2.OP = c(),
+DOLLAR.OP = c(CONSTANTS.ARGTYPE, CONSTANTS.ARGTYPE),
+DOLLARGETS.OP = c(CONSTANTS.ARGTYPE, CONSTANTS.ARGTYPE),
+ISNULL.OP = c(),
+ISLOGICAL.OP = c(),
+ISINTEGER.OP = c(),
+ISDOUBLE.OP = c(),
+ISCOMPLEX.OP = c(),
+ISCHARACTER.OP = c(),
+ISSYMBOL.OP = c(),
+ISOBJECT.OP = c(),
+ISNUMERIC.OP = c(),
+VECSUBSET.OP = c(CONSTANTS.ARGTYPE),
+MATSUBSET.OP = c(CONSTANTS.ARGTYPE),
+VECSUBASSIGN.OP = c(CONSTANTS.ARGTYPE),
+MATSUBASSIGN.OP = c(CONSTANTS.ARGTYPE),
+AND1ST.OP = c(CONSTANTS_DBG.ARGTYPE, LABEL.ARGTYPE),
+AND2ND.OP = c(CONSTANTS_DBG.ARGTYPE),
+OR1ST.OP = c(CONSTANTS_DBG.ARGTYPE, LABEL.ARGTYPE),
+OR2ND.OP = c(CONSTANTS_DBG.ARGTYPE),
+GETVAR_MISSOK.OP = c(CONSTANTS.ARGTYPE),
+DDVAL_MISSOK.OP = c(CONSTANTS.ARGTYPE),
+VISIBLE.OP = c(),
+SETVAR2.OP = c(CONSTANTS.ARGTYPE),
+STARTASSIGN2.OP = c(CONSTANTS.ARGTYPE),
+ENDASSIGN2.OP = c(CONSTANTS.ARGTYPE),
+SETTER_CALL.OP = c(CONSTANTS.ARGTYPE, CONSTANTS.ARGTYPE),
+GETTER_CALL.OP = c(CONSTANTS.ARGTYPE),
+SWAP.OP = c(),
+DUP2ND.OP = c(),
+SWITCH.OP = c(CONSTANTS.ARGTYPE, CONSTANTS.ARGTYPE, CONSTANTS.ARGTYPE, CONSTANTS.ARGTYPE),
+RETURNJMP.OP = c(),
+STARTSUBSET_N.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+STARTSUBASSIGN_N.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+VECSUBSET2.OP = c(CONSTANTS.ARGTYPE),
+MATSUBSET2.OP = c(CONSTANTS.ARGTYPE),
+VECSUBASSIGN2.OP = c(CONSTANTS.ARGTYPE),
+MATSUBASSIGN2.OP = c(CONSTANTS.ARGTYPE),
+STARTSUBSET2_N.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+STARTSUBASSIGN2_N.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE),
+SUBSET_N.OP = c(CONSTANTS.ARGTYPE, INT.ARGTYPE),
+SUBSET2_N.OP = c(CONSTANTS.ARGTYPE, INT.ARGTYPE),
+SUBASSIGN_N.OP = c(CONSTANTS.ARGTYPE, INT.ARGTYPE),
+SUBASSIGN2_N.OP = c(CONSTANTS.ARGTYPE, INT.ARGTYPE),
+LOG.OP = c(CONSTANTS.ARGTYPE),
+LOGBASE.OP = c(CONSTANTS.ARGTYPE),
+MATH1.OP = c(CONSTANTS.ARGTYPE, INT.ARGTYPE), #second argument is one of the math1funs
+DOTCALL.OP = c(CONSTANTS.ARGTYPE, INT.ARGTYPE),
+COLON.OP = c(SKIP.ARGTYPE),
+SEQALONG.OP = c(SKIP.ARGTYPE),
+SEQLEN.OP = c(SKIP.ARGTYPE),
+BASEGUARD.OP = c(CONSTANTS.ARGTYPE, LABEL.ARGTYPE)
 )
 @ 
 
+<<opcode argument count>>=
+Opcodes.argc <- lapply(Opcodes.argdescr, length)
+@ %def Opcodes.argc
+
+
 <<opcode names>>=
 Opcodes.names <- names(Opcodes.argc)
 @ %def Opcodes.names
@@ -6242,8 +6287,10 @@
 ## Opcode constants
 ##
 
-<<opcode argument counts>>
+<<opcode argument description>>
 
+<<opcode argument count>>
+
 <<opcode names>>
 
 <<opcode definitions>>
@@ -6627,7 +6674,9 @@
 
 <<[[disassemble]] function>>
 
+<<[[bcinfo]] function>>
 
+
 ##
 ## Experimental Utilities
 ##
